var tipuesearch = {"pages":[{"title":" Inference-Engine ","text":"Inference-Engine _        __ _ (_ )      / _|                                                   (_ ) _ _ __ | |_ ___ _ __ ___ _ __   ___ ___         ___ _ __   __ _ _ _ __   ___ \n | | '_ \\| _/ _ \\ '__/ _ \\ '_ \\ / __/ _ \\  __   / _ \\ '_ \\ / _` | | '_ \\ / _ \\\n | | | | | ||  __/ | |  __/ | | | (_|  __/ |__| |  __/ | | | (_| | | | | |  __/\n |_|_| |_|_| \\___|_|  \\___|_| |_|\\___\\___|       \\___|_| |_|\\__, |_|_| |_|\\___|\n                                                             __/ |             \n                                                            |___/ Inference-Engine Table of contents Overview Downloading, Building and testing Examples Documentation Overview Inference-Engine supports research in concurrent, large-batch inference and training of deep, feed-forward neural networks. Inference-Engine targets high-performance computing (HPC) applications with performance-critical inference and training needs.  The initial target application is in situ training of a cloud microphysics model proxy for the Intermediate Complexity Atmospheric Research ( ICAR ) model.  Such a proxy must support concurrent inference at every grid point at every time step of an ICAR run.  For validation purposes, Inference-Engine also supports the export and import of neural networks to and from Python by the companion package nexport . The features of Inference-Engine that make it suitable for use in HPC applications include Implementation in Fortran 2018. Exposing concurrency via Elemental , implicitly pure inference procedures, An elemental and implicitly pure activation strategy, and A pure training subroutine, Gathering network weights and biases into contiguous arrays for efficient memory access patterns, and User-controlled mini-batch size facilitating in situ training at application runtime. Making Inference-Engine's infer functions and train subroutines pure facilitates invoking those procedures inside Fortran do concurrent constructs, which some compilers can offload automatically to graphics processing units (GPUs).  The use of contiguous arrays facilitates spatial locality in memory access patterns.  User control of mini-batch size facilitates in-situ training at application runtime. The available optimizers for training neural networks are\n1. Stochastic gradient descent\n2. Adam (recommended) Build and Test With the Fortran Package Manager ( fpm ) and a recent version of a Fortran compiler installed, enter one of the commmands below to build the Inference-Engine library and run the test suite: GNU ( gfortran ) fpm test Intel ( ifx ) fpm test --compiler ifx Experimental: Automatic offloading of do concurrent to GPUs This capability is under development with the goal to facilitate GPU automatic offloading via the following command: fpm test -- compiler ifx -- flag \"-fopenmp-target-do-concurrent -qopenmp -fopenmp-targets=spir64\" LLVM ( flang-new ) Support for LLVM flang-new is under development and currently requires building flang-new from source with assumed-rank support enabled: fpm test --compiler flang-new --flag \"-mmlir -allow-assumed-rank\" A script that might help with building flang-new from source is in the handy-dandy repository. NAG ( nagfor ) -- under development fpm test --compiler nagfor --flag -fpp HPE ( crayftn.sh ) -- under development Support for the Cray Compiler Environment (CCE) Fortran compiler is under development.\nBuilding with the CCE ftn compiler wrapper requires an additional trivial wrapper.\nWith a shell script named crayftn.sh of the following form in your PATH #!/bin/bash ftn \" $@ \" execute the following command: fpm test --compiler crayftn.sh Examples The example subdirectory contains demonstrations of several intended use cases. Configuring a Training Run To see the format for a JSON configuration file that defines the hyperparameters and a new network configuration for a training run, execute the provided training-configuration output example program: % ./build/run-fpm.sh run --example print-training-configuration Project is up to date { \"hyperparameters\" : { \"mini-batches\" : 10 , \"learning rate\" : 1.50000000 , \"optimizer\" : \"adam\" } , \"network configuration\" : { \"skip connections\" : false , \"nodes per layer\" : [ 2 , 72 , 2 ], \"activation function\" : \"sigmoid\" } } As of this writing, the JSON file format is fragile.  Because an Intel ifx compiler bug prevents using our preferred JSON interface, rojff , Inference-Engine currently uses a very restricted JSON subset written and read by the sourcery utility's string_t type-bound procedures.  For this to work, it is important to keep input files as close as possible to the exact form shown above.  In particular, do not split, combine or reorder lines. Adding or removing whitespace should be ok. Documentation Please see the Inference-Engine GitHub Pages site for HTML documentation generated by [ ford ]. Developer Info Berkeley Lab","tags":"home","loc":"index.html"},{"title":"sigmoid_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Inherits type~~sigmoid_t~~InheritsGraph type~sigmoid_t sigmoid_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~sigmoid_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/sigmoid_t.html"},{"title":"difference_t – Inference-Engine ","text":"type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm interface private elemental module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"type/difference_t.html"},{"title":"exchange_t – Inference-Engine ","text":"type, public :: exchange_t Inherits type~~exchange_t~~InheritsGraph type~exchange_t exchange_t string_t string_t type~exchange_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~exchange_t->type~activation_strategy_t activation_strategy_ type~tensor_range_t tensor_range_t type~exchange_t->type~tensor_range_t input_range_, output_range_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type( tensor_range_t ), public :: input_range_ type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) type( tensor_range_t ), public :: output_range_ real(kind=rkind), public, allocatable :: weights_ (:,:,:)","tags":"","loc":"type/exchange_t.html"},{"title":"inference_engine_t – Inference-Engine ","text":"type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Inherits type~~inference_engine_t~~InheritsGraph type~inference_engine_t inference_engine_t string_t string_t type~inference_engine_t->string_t metadata_ type~activation_strategy_t activation_strategy_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~tensor_range_t tensor_range_t type~inference_engine_t->type~tensor_range_t input_range_, output_range_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type( tensor_range_t ), public :: input_range_ type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) type( tensor_range_t ), public :: output_range_ real(kind=rkind), public, allocatable :: weights_ (:,:,:) Constructor public        interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private impure module function construct_from_padded_arrays(metadata, weights, biases, nodes, input_range, output_range) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( inference_engine_t ) Type-Bound Procedures procedure, public :: activation_function_name interface private elemental module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) procedure, public :: assert_conformable_with interface private elemental module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine procedure, public :: infer interface public elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: map_from_output_range interface private elemental module function map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unnormalized via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) procedure, public :: map_to_input_range interface private elemental module function map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) procedure, public :: num_inputs interface private elemental module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer generic, public :: operator(-) => subtract private  interface subtract () Arguments None procedure, public :: skip interface private pure module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical procedure, public :: to_exchange interface private impure module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) procedure, public :: to_json interface private impure elemental module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) procedure, private :: subtract interface private elemental module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"type/inference_engine_t.html"},{"title":"step_t – Inference-Engine ","text":"type, public, extends( activation_strategy_t ) :: step_t Inherits type~~step_t~~InheritsGraph type~step_t step_t type~activation_strategy_t activation_strategy_t type~step_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/step_t.html"},{"title":"tensor_range_t – Inference-Engine ","text":"type, public :: tensor_range_t Inherited by type~~tensor_range_t~~InheritedByGraph type~tensor_range_t tensor_range_t type~exchange_t exchange_t type~exchange_t->type~tensor_range_t input_range_, output_range_ type~inference_engine_t inference_engine_t type~inference_engine_t->type~tensor_range_t input_range_, output_range_ type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~tensor_range_t input_range_, output_range_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: layer_ real, private, allocatable, dimension(:) :: maxima_ real, private, allocatable, dimension(:) :: minima_ Constructor public        interface tensor_range_t private pure module function from_components(layer, minima, maxima) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_range_t ) private module function from_json(lines) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_range_t ) Type-Bound Procedures procedure, public :: in_range interface private elemental module function in_range(self, tensor) result(is_in_range) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value logical procedure, public :: map_from_training_range interface private elemental module function map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: map_to_training_range interface private elemental module function map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) procedure, private :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: lhs class( tensor_range_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/tensor_range_t.html"},{"title":"layer_t – Inference-Engine ","text":"type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Inherits type~~layer_t~~InheritsGraph type~layer_t layer_t type~layer_t->type~layer_t next type~neuron_t neuron_t type~layer_t->type~neuron_t neuron type~neuron_t->type~neuron_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor public        interface layer_t private recursive module function construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target Type-Bound Procedures procedure, public :: count_inputs interface private module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer procedure, public :: count_layers interface private module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer procedure, public :: count_neurons interface private module function count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) procedure, public :: inference_engine interface private module function inference_engine(hidden_layers, metadata, output_layer, input_range, output_range) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_range_t ), intent(in) :: input_range type( tensor_range_t ), intent(in) :: output_range Return Value type( inference_engine_t ) procedure, public :: neurons_per_layer interface private module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer procedure, public :: next_allocated interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer","tags":"","loc":"type/layer_t.html"},{"title":"network_configuration_t – Inference-Engine ","text":"type, public :: network_configuration_t Inherited by type~~network_configuration_t~~InheritedByGraph type~network_configuration_t network_configuration_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Type-Bound Procedures procedure, public :: activation_name interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: skip_connections interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/network_configuration_t.html"},{"title":"hyperparameters_t – Inference-Engine ","text":"type, public :: hyperparameters_t Inherited by type~~hyperparameters_t~~InheritedByGraph type~hyperparameters_t hyperparameters_t type~training_configuration_t training_configuration_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor public        interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Type-Bound Procedures procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) procedure, public :: to_json interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/hyperparameters_t.html"},{"title":"gelu_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: gelu_t Inherits type~~gelu_t~~InheritsGraph type~gelu_t gelu_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~gelu_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( gelu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/gelu_t.html"},{"title":"neuron_t – Inference-Engine ","text":"type, public :: neuron_t linked list of neurons Inherited by type~~neuron_t~~InheritedByGraph type~neuron_t neuron_t type~neuron_t->type~neuron_t next type~layer_t layer_t type~layer_t->type~neuron_t neuron type~layer_t->type~layer_t next Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor public        interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Type-Bound Procedures procedure, public :: bias interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: next_allocated interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical procedure, public :: next_pointer interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer procedure, public :: num_inputs interface private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer procedure, public :: weights interface private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"type/neuron_t.html"},{"title":"mini_batch_t – Inference-Engine ","text":"type, public :: mini_batch_t Inherits type~~mini_batch_t~~InheritsGraph type~mini_batch_t mini_batch_t type~input_output_pair_t input_output_pair_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor public        interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) Type-Bound Procedures procedure, public :: input_output_pairs interface private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"type/mini_batch_t.html"},{"title":"trainable_engine_t – Inference-Engine ","text":"type, public :: trainable_engine_t Encapsulate the information needed to perform training Inherits type~~trainable_engine_t~~InheritsGraph type~trainable_engine_t trainable_engine_t string_t string_t type~trainable_engine_t->string_t metadata_ type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ type~tensor_range_t tensor_range_t type~trainable_engine_t->type~tensor_range_t input_range_, output_range_ type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type( tensor_range_t ), private :: input_range_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) type( tensor_range_t ), private :: output_range_ real(kind=rkind), private, allocatable :: w (:,:,:) Constructor public        interface trainable_engine_t private impure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private impure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_range_t ) :: input_range type( tensor_range_t ) :: output_range Return Value type( trainable_engine_t ) Type-Bound Procedures procedure, public :: assert_consistent interface private pure module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self procedure, public :: infer interface private elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) procedure, public :: map_from_input_training_range interface private elemental module function map_from_input_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: map_from_output_training_range interface private elemental module function map_from_output_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: map_to_input_training_range interface private elemental module function map_to_input_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: map_to_output_training_range interface private elemental module function map_to_output_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) procedure, public :: num_inputs interface private elemental module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_layers interface private elemental module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: num_outputs interface private elemental module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer procedure, public :: to_inference_engine interface private module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) procedure, public :: train interface private pure module subroutine train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"type/trainable_engine_t.html"},{"title":"activation_strategy_t – Inference-Engine ","text":"type, public, abstract :: activation_strategy_t Inherited by type~~activation_strategy_t~~InheritedByGraph type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t type~exchange_t exchange_t type~exchange_t->type~activation_strategy_t activation_strategy_ type~inference_engine_t inference_engine_t type~inference_engine_t->type~activation_strategy_t activation_strategy_ type~step_t step_t type~step_t->type~activation_strategy_t type~gelu_t gelu_t type~gelu_t->type~differentiable_activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred :: function_name elemental function function_name_i(self) result(string) Prototype Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/activation_strategy_t.html"},{"title":"swish_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: swish_t Inherits type~~swish_t~~InheritsGraph type~swish_t swish_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~swish_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/swish_t.html"},{"title":"relu_t – Inference-Engine ","text":"type, public, extends( differentiable_activation_strategy_t ) :: relu_t Inherits type~~relu_t~~InheritsGraph type~relu_t relu_t type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~relu_t->type~differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public, nopass :: activation interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public, nopass :: activation_derivative interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure, public :: function_name interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/relu_t.html"},{"title":"tensor_t – Inference-Engine ","text":"type, public :: tensor_t Inherited by type~~tensor_t~~InheritedByGraph type~tensor_t tensor_t type~input_output_pair_t input_output_pair_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: values_ (:) Constructor public        interface tensor_t private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) Type-Bound Procedures procedure, public :: num_components interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer procedure, public :: values interface private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"type/tensor_t.html"},{"title":"ubounds_t – Inference-Engine ","text":"type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical generic, public :: operator(==) => equals public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"type/ubounds_t.html"},{"title":"differentiable_activation_strategy_t – Inference-Engine ","text":"type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Inherits type~~differentiable_activation_strategy_t~~InheritsGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~activation_strategy_t activation_strategy_t type~differentiable_activation_strategy_t->type~activation_strategy_t Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~differentiable_activation_strategy_t~~InheritedByGraph type~differentiable_activation_strategy_t differentiable_activation_strategy_t type~gelu_t gelu_t type~gelu_t->type~differentiable_activation_strategy_t type~relu_t relu_t type~relu_t->type~differentiable_activation_strategy_t type~sigmoid_t sigmoid_t type~sigmoid_t->type~differentiable_activation_strategy_t type~swish_t swish_t type~swish_t->type~differentiable_activation_strategy_t type~trainable_engine_t trainable_engine_t type~trainable_engine_t->type~differentiable_activation_strategy_t differentiable_activation_strategy_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( activation_i ), public, deferred, nopass :: activation_derivative elemental function activation_i(x) result(y) Prototype Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) procedure( function_name_i ), public, deferred :: function_name elemental function function_name_i(self) result(string) Prototype Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"type/differentiable_activation_strategy_t.html"},{"title":"training_configuration_t – Inference-Engine ","text":"type, public, extends(file_t) :: training_configuration_t Inherits type~~training_configuration_t~~InheritsGraph type~training_configuration_t training_configuration_t file_t file_t type~training_configuration_t->file_t type~hyperparameters_t hyperparameters_t type~training_configuration_t->type~hyperparameters_t hyperparameters_ type~network_configuration_t network_configuration_t type~training_configuration_t->type~network_configuration_t network_configuration_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor public        interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Type-Bound Procedures procedure, public :: differentiable_activation_strategy interface private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable procedure, public :: equals interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical procedure, public :: learning_rate interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) procedure, public :: mini_batches interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer procedure, public :: nodes_per_layer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) generic, public :: operator(==) => equals private  interface equals () Arguments None procedure, public :: optimizer_name interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) procedure, public :: skip_connections interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical procedure, public :: to_json interface private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"type/training_configuration_t.html"},{"title":"input_output_pair_t – Inference-Engine ","text":"type, public :: input_output_pair_t Inherits type~~input_output_pair_t~~InheritsGraph type~input_output_pair_t input_output_pair_t type~tensor_t tensor_t type~input_output_pair_t->type~tensor_t inputs_, expected_outputs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Inherited by type~~input_output_pair_t~~InheritedByGraph type~input_output_pair_t input_output_pair_t type~mini_batch_t mini_batch_t type~mini_batch_t->type~input_output_pair_t input_output_pairs_ Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor public        interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) Type-Bound Procedures procedure, public :: expected_outputs interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) procedure, public :: inputs interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"type/input_output_pair_t.html"},{"title":"activation_i – Inference-Engine","text":"interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_i.html"},{"title":"function_name_i – Inference-Engine","text":"interface public elemental function function_name_i(self) result(string) Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name_i.html"},{"title":"activation – Inference-Engine","text":"interface Called by interface~~activation~~CalledByGraph interface~activation sigmoid_t%activation proc~activation_derivative~4 activation_derivative proc~activation_derivative~4->interface~activation proc~activation~5 activation proc~activation~5->interface~activation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"interface Called by interface~~activation_derivative~~CalledByGraph interface~activation_derivative sigmoid_t%activation_derivative proc~activation_derivative~4 activation_derivative proc~activation_derivative~4->interface~activation_derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name.html"},{"title":"infer – Inference-Engine","text":"interface Called by interface~~infer~~CalledByGraph interface~infer inference_engine_t%infer proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer.html"},{"title":"inference_engine_t – Inference-Engine","text":"public interface inference_engine_t Functions private impure elemental module function construct_from_json(file_) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private impure module function construct_from_padded_arrays(metadata, weights, biases, nodes, input_range, output_range) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine_t.html"},{"title":"activation_function_name – Inference-Engine","text":"interface Called by interface~~activation_function_name~~CalledByGraph interface~activation_function_name inference_engine_t%activation_function_name proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~activation_function_name program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"interface Called by interface~~assert_conformable_with~~CalledByGraph interface~assert_conformable_with inference_engine_t%assert_conformable_with proc~subtract subtract proc~subtract->interface~assert_conformable_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine","tags":"","loc":"interface/assert_conformable_with.html"},{"title":"map_from_output_range – Inference-Engine","text":"interface private elemental module function map_from_output_range(self, normalized_tensor) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) Description The result contains the output tensor values unnormalized via the inverse of the mapping used in training","tags":"","loc":"interface/map_from_output_range.html"},{"title":"map_to_input_range – Inference-Engine","text":"interface private elemental module function map_to_input_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Description The result contains the input tensor values normalized to fall on the range used during training","tags":"","loc":"interface/map_to_input_range.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Called by interface~~nodes_per_layer~~CalledByGraph interface~nodes_per_layer inference_engine_t%nodes_per_layer proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~nodes_per_layer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"interface private elemental module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/norm.html"},{"title":"num_inputs – Inference-Engine","text":"interface Called by interface~~num_inputs~~CalledByGraph interface~num_inputs inference_engine_t%num_inputs proc~to_json to_json proc~to_json->interface~num_inputs proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~num_inputs program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"interface Called by interface~~num_outputs~~CalledByGraph interface~num_outputs inference_engine_t%num_outputs proc~to_json to_json proc~to_json->interface~num_outputs proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~num_outputs program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs.html"},{"title":"skip – Inference-Engine","text":"interface private pure module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip.html"},{"title":"subtract – Inference-Engine","text":"interface private elemental module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t )","tags":"","loc":"interface/subtract.html"},{"title":"to_exchange – Inference-Engine","text":"interface Called by interface~~to_exchange~~CalledByGraph interface~to_exchange inference_engine_t%to_exchange proc~construct_from_inference_engine construct_from_inference_engine proc~construct_from_inference_engine->interface~to_exchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private impure module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t )","tags":"","loc":"interface/to_exchange.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~~CalledByGraph interface~to_json inference_engine_t%to_json proc~output output proc~output->interface~to_json proc~output~2 output proc~output~2->interface~to_json proc~output~3 output proc~output~3->interface~to_json proc~output~4 output proc~output~4->interface~to_json proc~output~5 output proc~output~5->interface~to_json proc~output~6 output proc~output~6->interface~to_json proc~output~7 output proc~output~7->interface~to_json proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~to_json program~learn_addition learn_addition program~learn_addition->proc~output~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~output~5 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output~3 program~learn_power_series learn_power_series program~learn_power_series->proc~output~4 program~train_and_write train_and_write program~train_and_write->proc~output~6 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~7 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private impure elemental module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"interface/to_json.html"},{"title":"difference_consistency – Inference-Engine","text":"pure subroutine difference_consistency(self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Calls proc~~difference_consistency~~CallsGraph proc~difference_consistency difference_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~difference_consistency~~CalledByGraph proc~difference_consistency difference_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~difference_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency proc~infer infer proc~infer->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/difference_consistency.html"},{"title":"inference_engine_consistency – Inference-Engine","text":"pure subroutine inference_engine_consistency(self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self Calls proc~~inference_engine_consistency~~CallsGraph proc~inference_engine_consistency inference_engine_consistency assert assert proc~inference_engine_consistency->assert intrinsic_array_t intrinsic_array_t proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~inference_engine_consistency~~CalledByGraph proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency assert_consistency interface~assert_consistency->proc~inference_engine_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency proc~infer infer proc~infer->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/inference_engine_consistency.html"},{"title":"set_activation_strategy – Inference-Engine","text":"impure subroutine set_activation_strategy(inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Calls proc~~set_activation_strategy~~CallsGraph proc~set_activation_strategy set_activation_strategy string string proc~set_activation_strategy->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_activation_strategy~~CalledByGraph proc~set_activation_strategy set_activation_strategy proc~construct_from_json construct_from_json proc~construct_from_json->proc~set_activation_strategy proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->proc~set_activation_strategy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/set_activation_strategy.html"},{"title":"assert_consistency – Inference-Engine","text":"private interface assert_consistency Calls interface~~assert_consistency~~CallsGraph interface~assert_consistency assert_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~assert_consistency~~CalledByGraph interface~assert_consistency assert_consistency proc~assert_conformable_with assert_conformable_with proc~assert_conformable_with->interface~assert_consistency proc~construct_from_json construct_from_json proc~construct_from_json->interface~assert_consistency proc~construct_from_padded_arrays construct_from_padded_arrays proc~construct_from_padded_arrays->interface~assert_consistency proc~infer infer proc~infer->interface~assert_consistency proc~nodes_per_layer nodes_per_layer proc~nodes_per_layer->interface~assert_consistency proc~num_inputs num_inputs proc~num_inputs->interface~assert_consistency proc~num_outputs num_outputs proc~num_outputs->interface~assert_consistency proc~subtract subtract proc~subtract->interface~assert_consistency proc~to_json to_json proc~to_json->interface~assert_consistency Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures pure subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistency.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~2.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~2.html"},{"title":"tensor_range_t – Inference-Engine","text":"public interface tensor_range_t Functions private pure module function from_components(layer, minima, maxima) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_range_t ) private module function from_json(lines) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_range_t )","tags":"","loc":"interface/tensor_range_t.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: lhs class( tensor_range_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals.html"},{"title":"in_range – Inference-Engine","text":"interface private elemental module function in_range(self, tensor) result(is_in_range) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value logical","tags":"","loc":"interface/in_range.html"},{"title":"map_from_training_range – Inference-Engine","text":"interface Called by interface~~map_from_training_range~~CalledByGraph interface~map_from_training_range tensor_range_t%map_from_training_range proc~infer infer proc~infer->interface~map_from_training_range proc~infer~2 infer proc~infer~2->interface~map_from_training_range proc~map_from_input_training_range map_from_input_training_range proc~map_from_input_training_range->interface~map_from_training_range proc~map_from_output_range map_from_output_range proc~map_from_output_range->interface~map_from_training_range proc~map_from_output_training_range map_from_output_training_range proc~map_from_output_training_range->interface~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_from_training_range.html"},{"title":"map_to_training_range – Inference-Engine","text":"interface Called by interface~~map_to_training_range~~CalledByGraph interface~map_to_training_range tensor_range_t%map_to_training_range proc~infer infer proc~infer->interface~map_to_training_range proc~infer~2 infer proc~infer~2->interface~map_to_training_range proc~map_to_input_range map_to_input_range proc~map_to_input_range->interface~map_to_training_range proc~map_to_input_training_range map_to_input_training_range proc~map_to_input_training_range->interface~map_to_training_range proc~map_to_output_training_range map_to_output_training_range proc~map_to_output_training_range->interface~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_to_training_range.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~2~~CalledByGraph interface~to_json~2 tensor_range_t%to_json proc~construct_from_json construct_from_json proc~construct_from_json->interface~to_json~2 proc~to_json to_json proc~to_json->interface~to_json~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~2.html"},{"title":"layer_t – Inference-Engine","text":"public interface layer_t Functions private recursive module function construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target","tags":"","loc":"interface/layer_t.html"},{"title":"count_inputs – Inference-Engine","text":"interface Called by interface~~count_inputs~~CalledByGraph interface~count_inputs layer_t%count_inputs proc~inference_engine inference_engine proc~inference_engine->interface~count_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer","tags":"","loc":"interface/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"interface Called by interface~~count_layers~~CalledByGraph interface~count_layers layer_t%count_layers proc~construct_from_json construct_from_json proc~construct_from_json->interface~count_layers proc~inference_engine inference_engine proc~inference_engine->interface~count_layers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"interface/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"interface Called by interface~~count_neurons~~CalledByGraph interface~count_neurons layer_t%count_neurons proc~construct_from_json construct_from_json proc~construct_from_json->interface~count_neurons proc~inference_engine inference_engine proc~inference_engine->interface~count_neurons Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer,allocatable,(:)","tags":"","loc":"interface/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"interface Called by interface~~inference_engine~~CalledByGraph interface~inference_engine layer_t%inference_engine proc~construct_from_json construct_from_json proc~construct_from_json->interface~inference_engine Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function inference_engine(hidden_layers, metadata, output_layer, input_range, output_range) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_range_t ), intent(in) :: input_range type( tensor_range_t ), intent(in) :: output_range Return Value type( inference_engine_t )","tags":"","loc":"interface/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"interface private module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer","tags":"","loc":"interface/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ),pointer","tags":"","loc":"interface/next_pointer.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~~CallsGraph proc~y y assert assert proc~y->assert interface~values tensor_t%values proc~y->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~~CalledByGraph proc~y y program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~~CalledByGraph proc~e e proc~perturbed_identity_network perturbed_identity_network proc~perturbed_identity_network->proc~e program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~~CallsGraph proc~perturbed_identity_network perturbed_identity_network proc~e e proc~perturbed_identity_network->proc~e string_t string_t proc~perturbed_identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~~CalledByGraph proc~perturbed_identity_network perturbed_identity_network program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~perturbed_identity_network Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~~CallsGraph proc~output output interface~to_json inference_engine_t%to_json proc~output->interface~to_json write_lines write_lines proc~output->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~~CalledByGraph proc~output output program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~output Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output.html"},{"title":"network_configuration_t – Inference-Engine","text":"public interface network_configuration_t Functions private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t )","tags":"","loc":"interface/network_configuration_t.html"},{"title":"activation_name – Inference-Engine","text":"interface Called by interface~~activation_name~~CalledByGraph interface~activation_name network_configuration_t%activation_name proc~differentiable_activation_strategy differentiable_activation_strategy proc~differentiable_activation_strategy->interface~activation_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/activation_name.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Called by interface~~nodes_per_layer~2~~CalledByGraph interface~nodes_per_layer~2 network_configuration_t%nodes_per_layer proc~nodes_per_layer~3 nodes_per_layer proc~nodes_per_layer~3->interface~nodes_per_layer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~2.html"},{"title":"skip_connections – Inference-Engine","text":"interface Called by interface~~skip_connections~~CalledByGraph interface~skip_connections network_configuration_t%skip_connections proc~skip_connections~2 skip_connections proc~skip_connections~2->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~3.html"},{"title":"hyperparameters_t – Inference-Engine","text":"public interface hyperparameters_t Functions private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t )","tags":"","loc":"interface/hyperparameters_t.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~3.html"},{"title":"learning_rate – Inference-Engine","text":"interface Called by interface~~learning_rate~~CalledByGraph interface~learning_rate hyperparameters_t%learning_rate proc~learning_rate learning_rate proc~learning_rate->interface~learning_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"interface Called by interface~~mini_batches~~CalledByGraph interface~mini_batches hyperparameters_t%mini_batches proc~mini_batches mini_batches proc~mini_batches->interface~mini_batches Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches.html"},{"title":"optimizer_name – Inference-Engine","text":"interface Called by interface~~optimizer_name~~CalledByGraph interface~optimizer_name hyperparameters_t%optimizer_name proc~optimizer_name optimizer_name proc~optimizer_name->interface~optimizer_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~4~~CalledByGraph interface~to_json~4 hyperparameters_t%to_json proc~from_components~3 from_components proc~from_components~3->interface~to_json~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~4.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( gelu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~3.html"},{"title":"neuron_t – Inference-Engine","text":"public interface neuron_t Functions private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t )","tags":"","loc":"interface/neuron_t.html"},{"title":"bias – Inference-Engine","text":"interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/bias.html"},{"title":"next_allocated – Inference-Engine","text":"interface Called by interface~~next_allocated~2~~CalledByGraph interface~next_allocated~2 neuron_t%next_allocated proc~construct_layer construct_layer proc~construct_layer->interface~next_allocated~2 proc~count_neurons count_neurons proc~count_neurons->interface~next_allocated~2 proc~neurons_per_layer neurons_per_layer proc~neurons_per_layer->interface~next_allocated~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"interface Called by interface~~next_pointer~2~~CalledByGraph interface~next_pointer~2 neuron_t%next_pointer proc~construct_layer construct_layer proc~construct_layer->interface~next_pointer~2 proc~count_neurons count_neurons proc~count_neurons->interface~next_pointer~2 proc~neurons_per_layer neurons_per_layer proc~neurons_per_layer->interface~next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ),pointer","tags":"","loc":"interface/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"interface Called by interface~~num_inputs~2~~CalledByGraph interface~num_inputs~2 neuron_t%num_inputs proc~count_inputs count_inputs proc~count_inputs->interface~num_inputs~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~2.html"},{"title":"weights – Inference-Engine","text":"interface Called by interface~~weights~~CalledByGraph interface~weights neuron_t%weights proc~construct_layer construct_layer proc~construct_layer->interface~weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/weights.html"},{"title":"mini_batch_t – Inference-Engine","text":"public interface mini_batch_t Functions private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"interface/mini_batch_t.html"},{"title":"input_output_pairs – Inference-Engine","text":"interface Called by interface~~input_output_pairs~~CalledByGraph interface~input_output_pairs mini_batch_t%input_output_pairs proc~train train proc~train->interface~input_output_pairs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ),allocatable,(:)","tags":"","loc":"interface/input_output_pairs.html"},{"title":"trainable_engine_t – Inference-Engine","text":"public interface trainable_engine_t Functions private impure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private impure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_range_t ) :: input_range type( tensor_range_t ) :: output_range Return Value type( trainable_engine_t )","tags":"","loc":"interface/trainable_engine_t.html"},{"title":"assert_consistent – Inference-Engine","text":"interface Called by interface~~assert_consistent~~CalledByGraph interface~assert_consistent trainable_engine_t%assert_consistent proc~construct_from_padded_arrays~2 construct_from_padded_arrays proc~construct_from_padded_arrays~2->interface~assert_consistent proc~infer~2 infer proc~infer~2->interface~assert_consistent proc~train train proc~train->interface~assert_consistent Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self","tags":"","loc":"interface/assert_consistent.html"},{"title":"infer – Inference-Engine","text":"interface private elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t )","tags":"","loc":"interface/infer~2.html"},{"title":"map_from_input_training_range – Inference-Engine","text":"interface private elemental module function map_from_input_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_from_input_training_range.html"},{"title":"map_from_output_training_range – Inference-Engine","text":"interface private elemental module function map_from_output_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_from_output_training_range.html"},{"title":"map_to_input_training_range – Inference-Engine","text":"interface private elemental module function map_to_input_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_to_input_training_range.html"},{"title":"map_to_output_training_range – Inference-Engine","text":"interface private elemental module function map_to_output_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t )","tags":"","loc":"interface/map_to_output_training_range.html"},{"title":"num_inputs – Inference-Engine","text":"interface Called by interface~~num_inputs~3~~CalledByGraph interface~num_inputs~3 trainable_engine_t%num_inputs proc~train train proc~train->interface~num_inputs~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_inputs~3.html"},{"title":"num_layers – Inference-Engine","text":"interface Called by interface~~num_layers~~CalledByGraph interface~num_layers trainable_engine_t%num_layers proc~train train proc~train->interface~num_layers Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private elemental module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_layers.html"},{"title":"num_outputs – Inference-Engine","text":"interface private elemental module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_outputs~2.html"},{"title":"to_inference_engine – Inference-Engine","text":"interface private module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t )","tags":"","loc":"interface/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"interface private pure module subroutine train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"interface/train.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~4.html"},{"title":"activation_derivative – Inference-Engine","text":"interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~4.html"},{"title":"activation – Inference-Engine","text":"interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation~5.html"},{"title":"activation_derivative – Inference-Engine","text":"interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"interface/activation_derivative~4.html"},{"title":"function_name – Inference-Engine","text":"interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/function_name~5.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~2~~CallsGraph proc~y~2 y assert assert proc~y~2->assert interface~values tensor_t%values proc~y~2->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~2~~CalledByGraph proc~y~2 y program~learn_addition learn_addition program~learn_addition->proc~y~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~2.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~2~~CalledByGraph proc~e~2 e proc~perturbed_identity_network~3 perturbed_identity_network proc~perturbed_identity_network~3->proc~e~2 program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~2.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~3~~CallsGraph proc~perturbed_identity_network~3 perturbed_identity_network proc~e~2 e proc~perturbed_identity_network~3->proc~e~2 string_t string_t proc~perturbed_identity_network~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~3~~CalledByGraph proc~perturbed_identity_network~3 perturbed_identity_network program~learn_addition learn_addition program~learn_addition->proc~perturbed_identity_network~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~3.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~2~~CallsGraph proc~output~2 output interface~to_json inference_engine_t%to_json proc~output~2->interface~to_json write_lines write_lines proc~output~2->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~2~~CalledByGraph proc~output~2 output program~learn_addition learn_addition program~learn_addition->proc~output~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~2.html"},{"title":"y – Inference-Engine","text":"public impure elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~3~~CallsGraph proc~y~3 y assert assert proc~y~3->assert interface~values tensor_t%values proc~y~3->interface~values proc~rsif RSIF proc~y~3->proc~rsif proc~rslf RSLF proc~y~3->proc~rslf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~3~~CalledByGraph proc~y~3 y program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~3.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~4~~CallsGraph proc~y~4 y assert assert proc~y~4->assert interface~values tensor_t%values proc~y~4->interface~values proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~4~~CalledByGraph proc~y~4 y program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~4.html"},{"title":"saturated_mixing_ratio – Inference-Engine","text":"private pure function saturated_mixing_ratio(T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real Called by proc~~saturated_mixing_ratio~~CalledByGraph proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4 y proc~y~4->proc~saturated_mixing_ratio program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/saturated_mixing_ratio.html"},{"title":"RSIF – Inference-Engine","text":"public  function RSIF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rsif~~CalledByGraph proc~rsif RSIF proc~y~3 y proc~y~3->proc~rsif program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF","tags":"","loc":"proc/rsif.html"},{"title":"RSLF – Inference-Engine","text":"public  function RSLF(P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real Called by proc~~rslf~~CalledByGraph proc~rslf RSLF proc~y~3 y proc~y~3->proc~rslf program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF","tags":"","loc":"proc/rslf.html"},{"title":"tensor_t – Inference-Engine","text":"public interface tensor_t Functions private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"interface/tensor_t.html"},{"title":"num_components – Inference-Engine","text":"interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/num_components.html"},{"title":"values – Inference-Engine","text":"interface Called by interface~~values~~CalledByGraph interface~values tensor_t%values proc~in_range in_range proc~in_range->interface~values proc~map_from_training_range map_from_training_range proc~map_from_training_range->interface~values proc~map_to_training_range map_to_training_range proc~map_to_training_range->interface~values proc~train train proc~train->interface~values proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->interface~values proc~y y proc~y->interface~values proc~y~2 y proc~y~2->interface~values proc~y~3 y proc~y~3->interface~values proc~y~4 y proc~y~4->interface~values proc~y~5 y proc~y~5->interface~values proc~y~6 y proc~y~6->interface~values program~learn_addition learn_addition program~learn_addition->proc~y~2 program~learn_exponentiation learn_exponentiation program~learn_exponentiation->proc~y program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~y~3 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y~5 program~learn_power_series learn_power_series program~learn_power_series->proc~y~6 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~y~4 program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind),allocatable,(:)","tags":"","loc":"interface/values.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t ) Calls proc~~y~5~~CallsGraph proc~y~5 y assert assert proc~y~5->assert interface~values tensor_t%values proc~y~5->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~5~~CalledByGraph proc~y~5 y program~learn_multiplication learn_multiplication program~learn_multiplication->proc~y~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~5.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~3~~CalledByGraph proc~e~3 e proc~perturbed_identity_network~4 perturbed_identity_network proc~perturbed_identity_network~4->proc~e~3 program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~3.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~4~~CallsGraph proc~perturbed_identity_network~4 perturbed_identity_network proc~e~3 e proc~perturbed_identity_network~4->proc~e~3 string_t string_t proc~perturbed_identity_network~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~4~~CalledByGraph proc~perturbed_identity_network~4 perturbed_identity_network program~learn_multiplication learn_multiplication program~learn_multiplication->proc~perturbed_identity_network~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~4.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~3~~CallsGraph proc~output~3 output interface~to_json inference_engine_t%to_json proc~output~3->interface~to_json write_lines write_lines proc~output~3->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~3~~CalledByGraph proc~output~3 output program~learn_multiplication learn_multiplication program~learn_multiplication->proc~output~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~3.html"},{"title":"y – Inference-Engine","text":"public elemental function y(x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) Calls proc~~y~6~~CallsGraph proc~y~6 y assert assert proc~y~6->assert interface~values tensor_t%values proc~y~6->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~y~6~~CalledByGraph proc~y~6 y program~learn_power_series learn_power_series program~learn_power_series->proc~y~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/y~6.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~4~~CalledByGraph proc~e~4 e proc~perturbed_identity_network~5 perturbed_identity_network proc~perturbed_identity_network~5->proc~e~4 program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~4.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~5~~CallsGraph proc~perturbed_identity_network~5 perturbed_identity_network proc~e~4 e proc~perturbed_identity_network~5->proc~e~4 string_t string_t proc~perturbed_identity_network~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~5~~CalledByGraph proc~perturbed_identity_network~5 perturbed_identity_network program~learn_power_series learn_power_series program~learn_power_series->proc~perturbed_identity_network~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~5.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~4~~CallsGraph proc~output~4 output interface~to_json inference_engine_t%to_json proc~output~4->interface~to_json write_lines write_lines proc~output~4->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~4~~CalledByGraph proc~output~4 output program~learn_power_series learn_power_series program~learn_power_series->proc~output~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~4.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~5~~CalledByGraph proc~e~5 e proc~perturbed_identity_network~6 perturbed_identity_network proc~perturbed_identity_network~6->proc~e~5 program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~5.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~6~~CallsGraph proc~perturbed_identity_network~6 perturbed_identity_network proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 string_t string_t proc~perturbed_identity_network~6->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~6~~CalledByGraph proc~perturbed_identity_network~6 perturbed_identity_network program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~perturbed_identity_network~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~6.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~~CallsGraph proc~open_plot_file_for_appending open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending->file_t lines lines proc~open_plot_file_for_appending->lines string string proc~open_plot_file_for_appending->string string_t string_t proc~open_plot_file_for_appending->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_plot_file_for_appending~~CalledByGraph proc~open_plot_file_for_appending open_plot_file_for_appending program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~open_plot_file_for_appending Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/open_plot_file_for_appending.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~5~~CallsGraph proc~output~5 output interface~to_json inference_engine_t%to_json proc~output~5->interface~to_json write_lines write_lines proc~output~5->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~5~~CalledByGraph proc~output~5 output program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~output~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~5.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~~CalledByGraph proc~print_diagnostics print_diagnostics program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->proc~print_diagnostics Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/print_diagnostics.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~7~~CallsGraph proc~perturbed_identity_network~7 perturbed_identity_network string_t string_t proc~perturbed_identity_network~7->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~7~~CalledByGraph proc~perturbed_identity_network~7 perturbed_identity_network program~train_and_write train_and_write program~train_and_write->proc~perturbed_identity_network~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~7.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~6~~CallsGraph proc~output~6 output interface~to_json inference_engine_t%to_json proc~output~6->interface~to_json write_lines write_lines proc~output~6->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~6~~CalledByGraph proc~output~6 output program~train_and_write train_and_write program~train_and_write->proc~output~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~6.html"},{"title":"equals – Inference-Engine","text":"public elemental function equals(lhs, rhs) result(lhs_equals_rhs) Type Bound ubounds_t Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~3.html"},{"title":"training_configuration_t – Inference-Engine","text":"public interface training_configuration_t Functions private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t )","tags":"","loc":"interface/training_configuration_t.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"interface Called by interface~~differentiable_activation_strategy~~CalledByGraph interface~differentiable_activation_strategy training_configuration_t%differentiable_activation_strategy proc~perturbed_identity_network~2 perturbed_identity_network proc~perturbed_identity_network~2->interface~differentiable_activation_strategy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ),allocatable","tags":"","loc":"interface/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"interface/equals~4.html"},{"title":"learning_rate – Inference-Engine","text":"interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"interface/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer","tags":"","loc":"interface/mini_batches~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"interface Called by interface~~nodes_per_layer~3~~CalledByGraph interface~nodes_per_layer~3 training_configuration_t%nodes_per_layer proc~perturbed_identity_network~2 perturbed_identity_network proc~perturbed_identity_network~2->interface~nodes_per_layer~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer,allocatable,(:)","tags":"","loc":"interface/nodes_per_layer~3.html"},{"title":"optimizer_name – Inference-Engine","text":"interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"interface/optimizer_name~2.html"},{"title":"skip_connections – Inference-Engine","text":"interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"interface/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"interface Called by interface~~to_json~5~~CalledByGraph interface~to_json~5 training_configuration_t%to_json program~print_training_configuration print_training_configuration program~print_training_configuration->interface~to_json~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t),allocatable,(:)","tags":"","loc":"interface/to_json~5.html"},{"title":"input_output_pair_t – Inference-Engine","text":"public interface input_output_pair_t Functions private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"interface/input_output_pair_t.html"},{"title":"shuffle – Inference-Engine","text":"interface Called by interface~~shuffle~~CalledByGraph interface~shuffle shuffle program~learn_addition learn_addition program~learn_addition->interface~shuffle program~learn_exponentiation learn_exponentiation program~learn_exponentiation->interface~shuffle program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->interface~shuffle program~learn_multiplication learn_multiplication program~learn_multiplication->interface~shuffle program~learn_power_series learn_power_series program~learn_power_series->interface~shuffle program~train_and_write train_and_write program~train_and_write->interface~shuffle program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->interface~shuffle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. public module subroutine shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"interface/shuffle.html"},{"title":"expected_outputs – Inference-Engine","text":"interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"interface/inputs.html"},{"title":"e – Inference-Engine","text":"pure function e(j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) Called by proc~~e~6~~CalledByGraph proc~e~6 e proc~perturbed_identity_network~8 perturbed_identity_network proc~perturbed_identity_network~8->proc~e~6 program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/e~6.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"function perturbed_identity_network(perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~8~~CallsGraph proc~perturbed_identity_network~8 perturbed_identity_network proc~e~6 e proc~perturbed_identity_network~8->proc~e~6 string_t string_t proc~perturbed_identity_network~8->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~perturbed_identity_network~8~~CalledByGraph proc~perturbed_identity_network~8 perturbed_identity_network program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~perturbed_identity_network~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~8.html"},{"title":"open_plot_file_for_appending – Inference-Engine","text":"subroutine open_plot_file_for_appending(plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock Calls proc~~open_plot_file_for_appending~2~~CallsGraph proc~open_plot_file_for_appending~2 open_plot_file_for_appending file_t file_t proc~open_plot_file_for_appending~2->file_t lines lines proc~open_plot_file_for_appending~2->lines string string proc~open_plot_file_for_appending~2->string string_t string_t proc~open_plot_file_for_appending~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~open_plot_file_for_appending~2~~CalledByGraph proc~open_plot_file_for_appending~2 open_plot_file_for_appending program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/open_plot_file_for_appending~2.html"},{"title":"output – Inference-Engine","text":"subroutine output(inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name Calls proc~~output~7~~CallsGraph proc~output~7 output interface~to_json inference_engine_t%to_json proc~output~7->interface~to_json write_lines write_lines proc~output~7->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~output~7~~CalledByGraph proc~output~7 output program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~output~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/output~7.html"},{"title":"print_diagnostics – Inference-Engine","text":"subroutine print_diagnostics(plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:) Called by proc~~print_diagnostics~2~~CalledByGraph proc~print_diagnostics~2 print_diagnostics program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->proc~print_diagnostics~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/print_diagnostics~2.html"},{"title":"identity_network – Inference-Engine","text":"function identity_network() result(inference_engine) Arguments None Return Value type( inference_engine_t ) Calls proc~~identity_network~~CallsGraph proc~identity_network identity_network string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~identity_network~~CalledByGraph proc~identity_network identity_network proc~write_read_query_infer write_read_query_infer proc~write_read_query_infer->proc~identity_network program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/identity_network.html"},{"title":"write_read_query_infer – Inference-Engine","text":"subroutine write_read_query_infer(output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name Calls proc~~write_read_query_infer~~CallsGraph proc~write_read_query_infer write_read_query_infer file_t file_t proc~write_read_query_infer->file_t interface~activation_function_name inference_engine_t%activation_function_name proc~write_read_query_infer->interface~activation_function_name interface~infer inference_engine_t%infer proc~write_read_query_infer->interface~infer interface~nodes_per_layer inference_engine_t%nodes_per_layer proc~write_read_query_infer->interface~nodes_per_layer interface~num_inputs inference_engine_t%num_inputs proc~write_read_query_infer->interface~num_inputs interface~num_outputs inference_engine_t%num_outputs proc~write_read_query_infer->interface~num_outputs interface~to_json inference_engine_t%to_json proc~write_read_query_infer->interface~to_json interface~values tensor_t%values proc~write_read_query_infer->interface~values proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network string string proc~write_read_query_infer->string write_lines write_lines proc~write_read_query_infer->write_lines string_t string_t proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_read_query_infer~~CalledByGraph proc~write_read_query_infer write_read_query_infer program~write_read_infer write_read_infer program~write_read_infer->proc~write_read_query_infer Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer","tags":"","loc":"proc/write_read_query_infer.html"},{"title":"activation_function_name – Inference-Engine","text":"module procedure activation_function_name elemental module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"proc/activation_function_name.html"},{"title":"assert_conformable_with – Inference-Engine","text":"module procedure assert_conformable_with elemental module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine Calls proc~~assert_conformable_with~~CallsGraph proc~assert_conformable_with assert_conformable_with assert assert proc~assert_conformable_with->assert interface~assert_consistency assert_consistency proc~assert_conformable_with->interface~assert_consistency intrinsic_array_t intrinsic_array_t proc~assert_conformable_with->intrinsic_array_t proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/assert_conformable_with.html"},{"title":"construct_from_json – Inference-Engine","text":"module procedure construct_from_json impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) Calls proc~~construct_from_json~~CallsGraph proc~construct_from_json construct_from_json assert assert proc~construct_from_json->assert interface~assert_consistency assert_consistency proc~construct_from_json->interface~assert_consistency interface~count_layers layer_t%count_layers proc~construct_from_json->interface~count_layers interface~count_neurons layer_t%count_neurons proc~construct_from_json->interface~count_neurons interface~inference_engine layer_t%inference_engine proc~construct_from_json->interface~inference_engine interface~to_json~2 tensor_range_t%to_json proc~construct_from_json->interface~to_json~2 lines lines proc~construct_from_json->lines proc~set_activation_strategy set_activation_strategy proc~construct_from_json->proc~set_activation_strategy string string proc~construct_from_json->string string_t string_t proc~construct_from_json->string_t proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~set_activation_strategy->string proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_json.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays impure module function construct_from_padded_arrays(metadata, weights, biases, nodes, input_range, output_range) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( inference_engine_t ) Calls proc~~construct_from_padded_arrays~~CallsGraph proc~construct_from_padded_arrays construct_from_padded_arrays interface~assert_consistency assert_consistency proc~construct_from_padded_arrays->interface~assert_consistency proc~set_activation_strategy set_activation_strategy proc~construct_from_padded_arrays->proc~set_activation_strategy proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency string string proc~set_activation_strategy->string assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_padded_arrays.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~~CallsGraph proc~infer infer activation activation proc~infer->activation interface~assert_consistency assert_consistency proc~infer->interface~assert_consistency interface~map_from_training_range tensor_range_t%map_from_training_range proc~infer->interface~map_from_training_range interface~map_to_training_range tensor_range_t%map_to_training_range proc~infer->interface~map_to_training_range values values proc~infer->values proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/infer.html"},{"title":"map_from_output_range – Inference-Engine","text":"module procedure map_from_output_range elemental module function map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) Calls proc~~map_from_output_range~~CallsGraph proc~map_from_output_range map_from_output_range interface~map_from_training_range tensor_range_t%map_from_training_range proc~map_from_output_range->interface~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_from_output_range.html"},{"title":"map_to_input_range – Inference-Engine","text":"module procedure map_to_input_range elemental module function map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_to_input_range~~CallsGraph proc~map_to_input_range map_to_input_range interface~map_to_training_range tensor_range_t%map_to_training_range proc~map_to_input_range->interface~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_to_input_range.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~nodes_per_layer~~CallsGraph proc~nodes_per_layer nodes_per_layer interface~assert_consistency assert_consistency proc~nodes_per_layer->interface~assert_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nodes_per_layer.html"},{"title":"norm – Inference-Engine","text":"module procedure norm elemental module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"proc/norm.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_inputs~~CallsGraph proc~num_inputs num_inputs interface~assert_consistency assert_consistency proc~num_inputs->interface~assert_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/num_inputs.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer Calls proc~~num_outputs~~CallsGraph proc~num_outputs num_outputs interface~assert_consistency assert_consistency proc~num_outputs->interface~assert_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/num_outputs.html"},{"title":"skip – Inference-Engine","text":"module procedure skip pure module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical Calls proc~~skip~~CallsGraph proc~skip skip string string proc~skip->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/skip.html"},{"title":"subtract – Inference-Engine","text":"module procedure subtract elemental module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) Calls proc~~subtract~~CallsGraph proc~subtract subtract interface~assert_conformable_with inference_engine_t%assert_conformable_with proc~subtract->interface~assert_conformable_with interface~assert_consistency assert_consistency proc~subtract->interface~assert_consistency proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency assert assert proc~difference_consistency->assert intrinsic_array_t intrinsic_array_t proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/subtract.html"},{"title":"to_exchange – Inference-Engine","text":"module procedure to_exchange impure module function to_exchange(self) result(exchange) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t )","tags":"","loc":"proc/to_exchange.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json impure elemental module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Calls proc~~to_json~~CallsGraph proc~to_json to_json assert assert proc~to_json->assert file_t file_t proc~to_json->file_t hidden_layer_weights hidden_layer_weights proc~to_json->hidden_layer_weights input_range_json input_range_json proc~to_json->input_range_json interface~assert_consistency assert_consistency proc~to_json->interface~assert_consistency interface~num_inputs inference_engine_t%num_inputs proc~to_json->interface~num_inputs interface~num_outputs inference_engine_t%num_outputs proc~to_json->interface~num_outputs interface~to_json~2 tensor_range_t%to_json proc~to_json->interface~to_json~2 intrinsic_array_t intrinsic_array_t proc~to_json->intrinsic_array_t output_range_json output_range_json proc~to_json->output_range_json separated_values separated_values proc~to_json->separated_values string string proc~to_json->string string_t string_t proc~to_json->string_t proc~difference_consistency difference_consistency interface~assert_consistency->proc~difference_consistency proc~inference_engine_consistency inference_engine_consistency interface~assert_consistency->proc~inference_engine_consistency proc~difference_consistency->assert proc~difference_consistency->intrinsic_array_t proc~inference_engine_consistency->assert proc~inference_engine_consistency->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json.html"},{"title":"assert_consistent – Inference-Engine","text":"module procedure assert_consistent pure module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Calls proc~~assert_consistent~~CallsGraph proc~assert_consistent assert_consistent assert assert proc~assert_consistent->assert intrinsic_array_t intrinsic_array_t proc~assert_consistent->intrinsic_array_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/assert_consistent.html"},{"title":"construct_from_inference_engine – Inference-Engine","text":"module procedure construct_from_inference_engine impure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) Calls proc~~construct_from_inference_engine~~CallsGraph proc~construct_from_inference_engine construct_from_inference_engine interface~to_exchange inference_engine_t%to_exchange proc~construct_from_inference_engine->interface~to_exchange Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_inference_engine.html"},{"title":"construct_from_padded_arrays – Inference-Engine","text":"module procedure construct_from_padded_arrays impure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( trainable_engine_t ) Calls proc~~construct_from_padded_arrays~2~~CallsGraph proc~construct_from_padded_arrays~2 construct_from_padded_arrays interface~assert_consistent trainable_engine_t%assert_consistent proc~construct_from_padded_arrays~2->interface~assert_consistent Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_from_padded_arrays~2.html"},{"title":"infer – Inference-Engine","text":"module procedure infer elemental module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) Calls proc~~infer~2~~CallsGraph proc~infer~2 infer activation activation proc~infer~2->activation interface~assert_consistent trainable_engine_t%assert_consistent proc~infer~2->interface~assert_consistent interface~map_from_training_range tensor_range_t%map_from_training_range proc~infer~2->interface~map_from_training_range interface~map_to_training_range tensor_range_t%map_to_training_range proc~infer~2->interface~map_to_training_range values values proc~infer~2->values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/infer~2.html"},{"title":"map_from_input_training_range – Inference-Engine","text":"module procedure map_from_input_training_range elemental module function map_from_input_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_from_input_training_range~~CallsGraph proc~map_from_input_training_range map_from_input_training_range interface~map_from_training_range tensor_range_t%map_from_training_range proc~map_from_input_training_range->interface~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_from_input_training_range.html"},{"title":"map_from_output_training_range – Inference-Engine","text":"module procedure map_from_output_training_range elemental module function map_from_output_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_from_output_training_range~~CallsGraph proc~map_from_output_training_range map_from_output_training_range interface~map_from_training_range tensor_range_t%map_from_training_range proc~map_from_output_training_range->interface~map_from_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_from_output_training_range.html"},{"title":"map_to_input_training_range – Inference-Engine","text":"module procedure map_to_input_training_range elemental module function map_to_input_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_to_input_training_range~~CallsGraph proc~map_to_input_training_range map_to_input_training_range interface~map_to_training_range tensor_range_t%map_to_training_range proc~map_to_input_training_range->interface~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_to_input_training_range.html"},{"title":"map_to_output_training_range – Inference-Engine","text":"module procedure map_to_output_training_range elemental module function map_to_output_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_to_output_training_range~~CallsGraph proc~map_to_output_training_range map_to_output_training_range interface~map_to_training_range tensor_range_t%map_to_training_range proc~map_to_output_training_range->interface~map_to_training_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_to_output_training_range.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs elemental module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_inputs~2.html"},{"title":"num_layers – Inference-Engine","text":"module procedure num_layers elemental module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_layers.html"},{"title":"num_outputs – Inference-Engine","text":"module procedure num_outputs elemental module function num_outputs(self) result(n_out) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_outputs~2.html"},{"title":"perturbed_identity_network – Inference-Engine","text":"module procedure perturbed_identity_network module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_range, output_range) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_range_t ) :: input_range type( tensor_range_t ) :: output_range Return Value type( trainable_engine_t ) Calls proc~~perturbed_identity_network~2~~CallsGraph proc~perturbed_identity_network~2 perturbed_identity_network interface~differentiable_activation_strategy training_configuration_t%differentiable_activation_strategy proc~perturbed_identity_network~2->interface~differentiable_activation_strategy interface~nodes_per_layer~3 training_configuration_t%nodes_per_layer proc~perturbed_identity_network~2->interface~nodes_per_layer~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/perturbed_identity_network~2.html"},{"title":"to_inference_engine – Inference-Engine","text":"module procedure to_inference_engine module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t )","tags":"","loc":"proc/to_inference_engine.html"},{"title":"train – Inference-Engine","text":"module procedure train pure module subroutine train(self, mini_batches_arr, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate Calls proc~~train~~CallsGraph proc~train train activation activation proc~train->activation activation_derivative activation_derivative proc~train->activation_derivative beta beta proc~train->beta expected_outputs expected_outputs proc~train->expected_outputs inputs inputs proc~train->inputs interface~assert_consistent trainable_engine_t%assert_consistent proc~train->interface~assert_consistent interface~input_output_pairs mini_batch_t%input_output_pairs proc~train->interface~input_output_pairs interface~num_inputs~3 trainable_engine_t%num_inputs proc~train->interface~num_inputs~3 interface~num_layers trainable_engine_t%num_layers proc~train->interface~num_layers interface~values tensor_t%values proc~train->interface~values obeta obeta proc~train->obeta Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/train.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation_derivative.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( gelu_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~~CallsGraph proc~function_name function_name string_t string_t proc~function_name->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation~2.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation_derivative~2.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~2~~CallsGraph proc~function_name~2 function_name string_t string_t proc~function_name~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~2.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation~3.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation_derivative~3.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~3~~CallsGraph proc~function_name~3 function_name string_t string_t proc~function_name~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~3.html"},{"title":"construct_layer – Inference-Engine","text":"module procedure construct_layer recursive module function construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target Calls proc~~construct_layer~~CallsGraph proc~construct_layer construct_layer assert assert proc~construct_layer->assert interface~next_allocated~2 neuron_t%next_allocated proc~construct_layer->interface~next_allocated~2 interface~next_pointer~2 neuron_t%next_pointer proc~construct_layer->interface~next_pointer~2 interface~weights neuron_t%weights proc~construct_layer->interface~weights string string proc~construct_layer->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct_layer.html"},{"title":"count_inputs – Inference-Engine","text":"module procedure count_inputs module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer Calls proc~~count_inputs~~CallsGraph proc~count_inputs count_inputs interface~num_inputs~2 neuron_t%num_inputs proc~count_inputs->interface~num_inputs~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_inputs.html"},{"title":"count_layers – Inference-Engine","text":"module procedure count_layers module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer","tags":"","loc":"proc/count_layers.html"},{"title":"count_neurons – Inference-Engine","text":"module procedure count_neurons module function count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) Calls proc~~count_neurons~~CallsGraph proc~count_neurons count_neurons interface~next_allocated~2 neuron_t%next_allocated proc~count_neurons->interface~next_allocated~2 interface~next_pointer~2 neuron_t%next_pointer proc~count_neurons->interface~next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/count_neurons.html"},{"title":"inference_engine – Inference-Engine","text":"module procedure inference_engine module function inference_engine(hidden_layers, metadata, output_layer, input_range, output_range) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_range_t ), intent(in) :: input_range type( tensor_range_t ), intent(in) :: output_range Return Value type( inference_engine_t ) Calls proc~~inference_engine~~CallsGraph proc~inference_engine inference_engine assert assert proc~inference_engine->assert bias bias proc~inference_engine->bias biases biases proc~inference_engine->biases interface~count_inputs layer_t%count_inputs proc~inference_engine->interface~count_inputs interface~count_layers layer_t%count_layers proc~inference_engine->interface~count_layers interface~count_neurons layer_t%count_neurons proc~inference_engine->interface~count_neurons next_allocated next_allocated proc~inference_engine->next_allocated next_pointer next_pointer proc~inference_engine->next_pointer weights weights proc~inference_engine->weights Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/inference_engine.html"},{"title":"neurons_per_layer – Inference-Engine","text":"module procedure neurons_per_layer module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer Calls proc~~neurons_per_layer~~CallsGraph proc~neurons_per_layer neurons_per_layer interface~next_allocated~2 neuron_t%next_allocated proc~neurons_per_layer->interface~next_allocated~2 interface~next_pointer~2 neuron_t%next_pointer proc~neurons_per_layer->interface~next_pointer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/neurons_per_layer.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/next_allocated.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer","tags":"","loc":"proc/next_pointer.html"},{"title":"bias – Inference-Engine","text":"module procedure bias module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"proc/bias.html"},{"title":"construct – Inference-Engine","text":"module procedure construct pure recursive module function construct(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) Calls proc~~construct~~CallsGraph proc~construct construct assert assert proc~construct->assert string string proc~construct->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/construct.html"},{"title":"next_allocated – Inference-Engine","text":"module procedure next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/next_allocated~2.html"},{"title":"next_pointer – Inference-Engine","text":"module procedure next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer","tags":"","loc":"proc/next_pointer~2.html"},{"title":"num_inputs – Inference-Engine","text":"module procedure num_inputs pure module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_inputs~3.html"},{"title":"weights – Inference-Engine","text":"module procedure weights module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"proc/weights.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: lhs class( tensor_range_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~~CallsGraph proc~equals equals assert assert proc~equals->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components pure module function from_components(layer, minima, maxima) result(tensor_range) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_range_t ) Calls proc~~from_components~~CallsGraph proc~from_components from_components assert assert proc~from_components->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_components.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json module function from_json(lines) result(tensor_range) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_range_t ) Calls proc~~from_json~~CallsGraph proc~from_json from_json assert assert proc~from_json->assert get_json_key get_json_key proc~from_json->get_json_key get_json_value get_json_value proc~from_json->get_json_value string_t string_t proc~from_json->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json.html"},{"title":"in_range – Inference-Engine","text":"module procedure in_range elemental module function in_range(self, tensor) result(is_in_range) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value logical Calls proc~~in_range~~CallsGraph proc~in_range in_range interface~values tensor_t%values proc~in_range->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/in_range.html"},{"title":"map_from_training_range – Inference-Engine","text":"module procedure map_from_training_range elemental module function map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_from_training_range~~CallsGraph proc~map_from_training_range map_from_training_range interface~values tensor_t%values proc~map_from_training_range->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_from_training_range.html"},{"title":"map_to_training_range – Inference-Engine","text":"module procedure map_to_training_range elemental module function map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) Calls proc~~map_to_training_range~~CallsGraph proc~map_to_training_range map_to_training_range interface~values tensor_t%values proc~map_to_training_range->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/map_to_training_range.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~2~~CallsGraph proc~to_json~2 to_json assert assert proc~to_json~2->assert separated_values separated_values proc~to_json~2->separated_values string_t string_t proc~to_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~2.html"},{"title":"activation_name – Inference-Engine","text":"module procedure activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"proc/activation_name.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~2~~CallsGraph proc~equals~2 equals assert assert proc~equals~2->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals~2.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t )","tags":"","loc":"proc/from_components~2.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) Calls proc~~from_json~2~~CallsGraph proc~from_json~2 from_json assert assert proc~from_json~2->assert get_json_key get_json_key proc~from_json~2->get_json_key get_json_value get_json_value proc~from_json~2->get_json_value string_t string_t proc~from_json~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~2.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:)","tags":"","loc":"proc/nodes_per_layer~2.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical","tags":"","loc":"proc/skip_connections.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~3~~CallsGraph proc~to_json~3 to_json string_t string_t proc~to_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~3.html"},{"title":"construct – Inference-Engine","text":"module procedure construct elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t )","tags":"","loc":"proc/construct~2.html"},{"title":"expected_outputs – Inference-Engine","text":"module procedure expected_outputs elemental module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/expected_outputs.html"},{"title":"inputs – Inference-Engine","text":"module procedure inputs elemental module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t )","tags":"","loc":"proc/inputs.html"},{"title":"shuffle – Inference-Engine","text":"module procedure shuffle module subroutine shuffle(pairs) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"proc/shuffle.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind)","tags":"","loc":"proc/activation~4.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~4~~CallsGraph proc~function_name~4 function_name string_t string_t proc~function_name~4->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~4.html"},{"title":"activation – Inference-Engine","text":"module procedure activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Calls proc~~activation~5~~CallsGraph proc~activation~5 activation interface~activation sigmoid_t%activation proc~activation~5->interface~activation Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/activation~5.html"},{"title":"activation_derivative – Inference-Engine","text":"module procedure activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) Calls proc~~activation_derivative~4~~CallsGraph proc~activation_derivative~4 activation_derivative interface~activation sigmoid_t%activation proc~activation_derivative~4->interface~activation interface~activation_derivative sigmoid_t%activation_derivative proc~activation_derivative~4->interface~activation_derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/activation_derivative~4.html"},{"title":"function_name – Inference-Engine","text":"module procedure function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t) Calls proc~~function_name~5~~CallsGraph proc~function_name~5 function_name string_t string_t proc~function_name~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/function_name~5.html"},{"title":"construct_from_components – Inference-Engine","text":"module procedure construct_from_components pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t )","tags":"","loc":"proc/construct_from_components.html"},{"title":"num_components – Inference-Engine","text":"module procedure num_components pure module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/num_components.html"},{"title":"values – Inference-Engine","text":"module procedure values pure module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"proc/values.html"},{"title":"differentiable_activation_strategy – Inference-Engine","text":"module procedure differentiable_activation_strategy module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable Calls proc~~differentiable_activation_strategy~~CallsGraph proc~differentiable_activation_strategy differentiable_activation_strategy interface~activation_name network_configuration_t%activation_name proc~differentiable_activation_strategy->interface~activation_name string string proc~differentiable_activation_strategy->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/differentiable_activation_strategy.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"proc/equals~4.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) Calls proc~~from_components~3~~CallsGraph proc~from_components~3 from_components file_t file_t proc~from_components~3->file_t interface~to_json~4 hyperparameters_t%to_json proc~from_components~3->interface~to_json~4 string_t string_t proc~from_components~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_components~3.html"},{"title":"from_file – Inference-Engine","text":"module procedure from_file module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) Calls proc~~from_file~~CallsGraph proc~from_file from_file assert assert proc~from_file->assert lines lines proc~from_file->lines string string proc~from_file->string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_file.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) Calls proc~~learning_rate~~CallsGraph proc~learning_rate learning_rate interface~learning_rate hyperparameters_t%learning_rate proc~learning_rate->interface~learning_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/learning_rate.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer Calls proc~~mini_batches~~CallsGraph proc~mini_batches mini_batches interface~mini_batches hyperparameters_t%mini_batches proc~mini_batches->interface~mini_batches Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/mini_batches.html"},{"title":"nodes_per_layer – Inference-Engine","text":"module procedure nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) Calls proc~~nodes_per_layer~3~~CallsGraph proc~nodes_per_layer~3 nodes_per_layer interface~nodes_per_layer~2 network_configuration_t%nodes_per_layer proc~nodes_per_layer~3->interface~nodes_per_layer~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/nodes_per_layer~3.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) Calls proc~~optimizer_name~~CallsGraph proc~optimizer_name optimizer_name interface~optimizer_name hyperparameters_t%optimizer_name proc~optimizer_name->interface~optimizer_name Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/optimizer_name.html"},{"title":"skip_connections – Inference-Engine","text":"module procedure skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical Calls proc~~skip_connections~2~~CallsGraph proc~skip_connections~2 skip_connections interface~skip_connections network_configuration_t%skip_connections proc~skip_connections~2->interface~skip_connections Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/skip_connections~2.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~4~~CallsGraph proc~to_json~4 to_json lines lines proc~to_json~4->lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~4.html"},{"title":"construct – Inference-Engine","text":"module procedure construct pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t )","tags":"","loc":"proc/construct~3.html"},{"title":"input_output_pairs – Inference-Engine","text":"module procedure input_output_pairs pure module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"proc/input_output_pairs.html"},{"title":"equals – Inference-Engine","text":"module procedure equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical Calls proc~~equals~5~~CallsGraph proc~equals~5 equals assert assert proc~equals~5->assert Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/equals~5.html"},{"title":"from_components – Inference-Engine","text":"module procedure from_components pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t )","tags":"","loc":"proc/from_components~4.html"},{"title":"from_json – Inference-Engine","text":"module procedure from_json pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) Calls proc~~from_json~3~~CallsGraph proc~from_json~3 from_json assert assert proc~from_json~3->assert get_json_key get_json_key proc~from_json~3->get_json_key get_json_value get_json_value proc~from_json~3->get_json_value string_t string_t proc~from_json~3->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/from_json~3.html"},{"title":"learning_rate – Inference-Engine","text":"module procedure learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind)","tags":"","loc":"proc/learning_rate~2.html"},{"title":"mini_batches – Inference-Engine","text":"module procedure mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer","tags":"","loc":"proc/mini_batches~2.html"},{"title":"optimizer_name – Inference-Engine","text":"module procedure optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) Calls proc~~optimizer_name~2~~CallsGraph proc~optimizer_name~2 optimizer_name string_t string_t proc~optimizer_name~2->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/optimizer_name~2.html"},{"title":"to_json – Inference-Engine","text":"module procedure to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Calls proc~~to_json~5~~CallsGraph proc~to_json~5 to_json string_t string_t proc~to_json~5->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"proc/to_json~5.html"},{"title":"sigmoid_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m julienne_string_m module~~sigmoid_m~~UsesGraph module~sigmoid_m sigmoid_m julienne_string_m julienne_string_m module~sigmoid_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: sigmoid_s module~~sigmoid_m~~UsedByGraph module~sigmoid_m sigmoid_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~sigmoid_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~sigmoid_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: sigmoid_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/sigmoid_m.html"},{"title":"inference_engine_m_ – Inference-Engine","text":"Define an abstraction that supports inference operationsn on a neural network Uses tensor_m kind_parameters_m tensor_range_m differentiable_activation_strategy_m julienne_file_m activation_strategy_m julienne_string_m module~~inference_engine_m_~~UsesGraph module~inference_engine_m_ inference_engine_m_ julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m julienne_string_m julienne_string_m module~inference_engine_m_->julienne_string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m_->module~tensor_range_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: inference_engine_s module~~inference_engine_m_~~UsedByGraph module~inference_engine_m_ inference_engine_m_ module~inference_engine_m inference_engine_m module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~layer_m->module~inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: key (*) = [character(len=len(\"usingSkipConnections\"))::\"modelName\", \"modelAuthor\", \"compilationDate\", \"activationFunction\", \"usingSkipConnections\"] Interfaces interface public elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) public        interface inference_engine_t private impure elemental module function construct_from_json(file_) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) private impure module function construct_from_padded_arrays(metadata, weights, biases, nodes, input_range, output_range) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( inference_engine_t ) interface private elemental module function activation_function_name(self) result(activation_name) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) interface private elemental module subroutine assert_conformable_with(self, inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine interface private elemental module function map_from_output_range(self, normalized_tensor) result(tensor) Implementation → The result contains the output tensor values unnormalized via the inverse of the mapping used in training Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) interface private elemental module function map_to_input_range(self, tensor) result(normalized_tensor) Implementation → The result contains the input tensor values normalized to fall on the range used during training Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private pure module function nodes_per_layer(self) result(node_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function norm(self) result(norm_of_self) Implementation → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function num_inputs(self) result(input_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_outputs(self) result(output_count) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer interface private pure module function skip(self) result(use_skip_connections) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical interface private elemental module function subtract(self, rhs) result(difference) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) interface private impure module function to_exchange(self) result(exchange) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) interface private impure elemental module function to_json(self) result(json_file) Implementation → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t) Derived Types type, public :: difference_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: biases_difference_ (:,:) integer, private, allocatable :: nodes_difference_ (:) real(kind=rkind), private, allocatable :: weights_difference_ (:,:,:) Type-Bound Procedures procedure, public :: norm type, public :: exchange_t Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type( tensor_range_t ), public :: input_range_ type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) type( tensor_range_t ), public :: output_range_ real(kind=rkind), public, allocatable :: weights_ (:,:,:) type, public :: inference_engine_t Encapsulate the minimal information needed to perform inference Components Type Visibility Attributes Name Initial class( activation_strategy_t ), public, allocatable :: activation_strategy_ real(kind=rkind), public, allocatable :: biases_ (:,:) type( tensor_range_t ), public :: input_range_ type(string_t), public :: metadata_ (size(key)) integer, public, allocatable :: nodes_ (:) type( tensor_range_t ), public :: output_range_ real(kind=rkind), public, allocatable :: weights_ (:,:,:) Constructor private\n\n                    impure, elemental, module\n                    function construct_from_json (file_) private\n\n                    impure, module\n                    function construct_from_padded_arrays (metadata, weights, biases, nodes, input_range, output_range) Type-Bound Procedures procedure, public :: activation_function_name procedure, public :: assert_conformable_with procedure, public :: infer procedure, public :: map_from_output_range procedure, public :: map_to_input_range procedure, public :: nodes_per_layer procedure, public :: num_inputs procedure, public :: num_outputs generic, public :: operator(-) => subtract procedure, public :: skip procedure, public :: to_exchange procedure, public :: to_json procedure, private :: subtract","tags":"","loc":"module/inference_engine_m_.html"},{"title":"step_m – Inference-Engine","text":"Uses kind_parameters_m julienne_string_m activation_strategy_m module~~step_m~~UsesGraph module~step_m step_m julienne_string_m julienne_string_m module~step_m->julienne_string_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~kind_parameters_m kind_parameters_m module~step_m->module~kind_parameters_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: step_s module~~step_m~~UsedByGraph module~step_m step_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~step_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~step_m module~step_s step_s module~step_s->module~step_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( activation_strategy_t ) :: step_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public :: function_name","tags":"","loc":"module/step_m.html"},{"title":"tensor_range_m – Inference-Engine","text":"Uses tensor_m julienne_m module~~tensor_range_m~~UsesGraph module~tensor_range_m tensor_range_m julienne_m julienne_m module~tensor_range_m->julienne_m module~tensor_m tensor_m module~tensor_range_m->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: tensor_range_s module~~tensor_range_m~~UsedByGraph module~tensor_range_m tensor_range_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~tensor_range_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~inference_engine_m_->module~tensor_range_m module~layer_m layer_m module~layer_m->module~tensor_range_m module~layer_m->module~inference_engine_m_ module~tensor_range_s tensor_range_s module~tensor_range_s->module~tensor_range_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~inference_engine_m_ module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tensor_range_t private pure module function from_components(layer, minima, maxima) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_range_t ) private module function from_json(lines) result(tensor_range) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_range_t ) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: lhs class( tensor_range_t ), intent(in) :: rhs Return Value logical interface private elemental module function in_range(self, tensor) result(is_in_range) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value logical interface private elemental module function map_from_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function map_to_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: tensor_range_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: layer_ real, private, allocatable, dimension(:) :: maxima_ real, private, allocatable, dimension(:) :: minima_ Constructor private\n\n                    pure, module\n                    function from_components (layer, minima, maxima) private\n\n                    module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: in_range procedure, public :: map_from_training_range procedure, public :: map_to_training_range generic, public :: operator(==) => equals procedure, public :: to_json procedure, private :: equals","tags":"","loc":"module/tensor_range_m.html"},{"title":"layer_m – Inference-Engine","text":"Uses neuron_m inference_engine_m_ kind_parameters_m tensor_range_m julienne_string_m module~~layer_m~~UsesGraph module~layer_m layer_m julienne_string_m julienne_string_m module~layer_m->julienne_string_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~tensor_range_m tensor_range_m module~layer_m->module~tensor_range_m module~inference_engine_m_->julienne_string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~neuron_m->julienne_string_m module~neuron_m->module~kind_parameters_m julienne_m julienne_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: layer_s module~~layer_m~~UsedByGraph module~layer_m layer_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~layer_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface layer_t private recursive module function construct_layer(layer_lines, start) result(layer) Implementation → construct a linked list of layer_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target interface private module function count_inputs(layer) result(num_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer interface private module function count_layers(layer) result(num_layers) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer interface private module function count_neurons(layer) result(neurons_per_layer_result) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) interface private module function inference_engine(hidden_layers, metadata, output_layer, input_range, output_range) result(inference_engine_) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_range_t ), intent(in) :: input_range type( tensor_range_t ), intent(in) :: output_range Return Value type( inference_engine_t ) interface private module function neurons_per_layer(self) result(num_neurons) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer Derived Types type, public :: layer_t linked list of layers, each comprised of a linked list of neurons Components Type Visibility Attributes Name Initial type( neuron_t ), private :: neuron linked list of this layer's neurons type( layer_t ), private, allocatable :: next next layer Constructor private\n\n                    recursive, module\n                    function construct_layer (layer_lines, start) construct a linked list of layer_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: count_inputs procedure, public :: count_layers procedure, public :: count_neurons procedure, public :: inference_engine procedure, public :: neurons_per_layer procedure, public :: next_allocated procedure, public :: next_pointer","tags":"","loc":"module/layer_m.html"},{"title":"exponentiation_m – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~exponentiation_m~~UsesGraph module~exponentiation_m exponentiation_m assert_m assert_m module~exponentiation_m->assert_m module~inference_engine_m inference_engine_m module~exponentiation_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~exponentiation_m~~UsedByGraph module~exponentiation_m exponentiation_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~exponentiation_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/exponentiation_m.html"},{"title":"network_configuration_m – Inference-Engine","text":"Uses julienne_string_m module~~network_configuration_m~~UsesGraph module~network_configuration_m network_configuration_m julienne_string_m julienne_string_m module~network_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: network_configuration_s module~~network_configuration_m~~UsedByGraph module~network_configuration_m network_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~network_configuration_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~network_configuration_s network_configuration_s module~network_configuration_s->module~network_configuration_m module~training_configuration_m->module~network_configuration_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface network_configuration_t private pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) private pure module function from_json(lines) result(network_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) interface private elemental module function activation_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: network_configuration_t Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: activation_name_ integer, private, allocatable :: nodes_per_layer_ (:) logical, private :: skip_connections_ = .false. Constructor private\n\n                    pure, module\n                    function from_components (skip_connections, nodes_per_layer, activation_name) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: activation_name procedure, public :: equals procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/network_configuration_m.html"},{"title":"hyperparameters_m – Inference-Engine","text":"Uses kind_parameters_m julienne_string_m module~~hyperparameters_m~~UsesGraph module~hyperparameters_m hyperparameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: hyperparameters_s module~~hyperparameters_m~~UsedByGraph module~hyperparameters_m hyperparameters_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~hyperparameters_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m->module~hyperparameters_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface hyperparameters_t private pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) private pure module function from_json(lines) result(hyperparameters) Implementation → Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) interface private elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) interface private pure module function to_json(self) result(lines) Implementation → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public :: hyperparameters_t Components Type Visibility Attributes Name Initial real, private :: learning_rate_ = 1.5 integer, private :: mini_batches_ = 10 character(len=:), private, allocatable :: optimizer_ Constructor private\n\n                    pure, module\n                    function from_components (mini_batches, learning_rate, optimizer) private\n\n                    pure, module\n                    function from_json (lines) Type-Bound Procedures procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: to_json","tags":"","loc":"module/hyperparameters_m.html"},{"title":"inference_engine_m – Inference-Engine","text":"Specify the user-facing modules, derived types, and type parameters Uses tensor_m inference_engine_m_ kind_parameters_m network_configuration_m tensor_range_m relu_m differentiable_activation_strategy_m step_m hyperparameters_m activation_strategy_m input_output_pair_m gelu_m trainable_engine_m mini_batch_m ubounds_m sigmoid_m training_configuration_m swish_m module~~inference_engine_m~~UsesGraph module~inference_engine_m inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~inference_engine_m~~UsedByGraph module~inference_engine_m inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"module/inference_engine_m.html"},{"title":"gelu_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m julienne_string_m module~~gelu_m~~UsesGraph module~gelu_m gelu_m julienne_string_m julienne_string_m module~gelu_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~gelu_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: gelu_s module~~gelu_m~~UsedByGraph module~gelu_m gelu_m module~gelu_s gelu_s module~gelu_s->module~gelu_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~gelu_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~gelu_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( gelu_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: gelu_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/gelu_m.html"},{"title":"neuron_m – Inference-Engine","text":"Uses kind_parameters_m julienne_string_m module~~neuron_m~~UsesGraph module~neuron_m neuron_m julienne_string_m julienne_string_m module~neuron_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: neuron_s module~~neuron_m~~UsedByGraph module~neuron_m neuron_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~neuron_m module~layer_m layer_m module~inference_engine_s->module~layer_m module~layer_m->module~neuron_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface neuron_t private pure recursive module function construct(neuron_lines, start) result(neuron) Implementation → construct linked list of neuron_t objects from an array of JSON-formatted text lines Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) interface private module function bias(self) result(my_bias) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) interface private module function next_allocated(self) result(next_is_allocated) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical interface private module function next_pointer(self) result(next_ptr) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer interface private pure module function num_inputs(self) result(size_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer interface private module function weights(self) result(my_weights) Implementation → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:) Derived Types type, public :: neuron_t linked list of neurons Components Type Visibility Attributes Name Initial real(kind=rkind), private :: bias_ type( neuron_t ), private, allocatable :: next real(kind=rkind), private, allocatable :: weights_ (:) Constructor private\n\n                    pure, recursive, module\n                    function construct (neuron_lines, start) construct linked list of neuron_t objects from an array of JSON-formatted text lines Type-Bound Procedures procedure, public :: bias procedure, public :: next_allocated procedure, public :: next_pointer procedure, public :: num_inputs procedure, public :: weights","tags":"","loc":"module/neuron_m.html"},{"title":"mini_batch_m – Inference-Engine","text":"Uses input_output_pair_m kind_parameters_m module~~mini_batch_m~~UsesGraph module~mini_batch_m mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: mini_batch_s module~~mini_batch_m~~UsedByGraph module~mini_batch_m mini_batch_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~trainable_engine_m->module~mini_batch_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface mini_batch_t private pure module function construct(input_output_pairs) result(mini_batch) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) interface private pure module function input_output_pairs(self) result(my_input_output_pairs) Implementation → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:) Derived Types type, public :: mini_batch_t Components Type Visibility Attributes Name Initial type( input_output_pair_t ), private, allocatable :: input_output_pairs_ (:) Constructor private\n\n                    pure, module\n                    function construct (input_output_pairs) Type-Bound Procedures procedure, public :: input_output_pairs","tags":"","loc":"module/mini_batch_m.html"},{"title":"trainable_engine_m – Inference-Engine","text":"Define an abstraction that supports training a neural network Uses tensor_m inference_engine_m_ kind_parameters_m tensor_range_m differentiable_activation_strategy_m julienne_string_m mini_batch_m training_configuration_m module~~trainable_engine_m~~UsesGraph module~trainable_engine_m trainable_engine_m julienne_string_m julienne_string_m module~trainable_engine_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~tensor_m tensor_m module~trainable_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~trainable_engine_m->module~tensor_range_m module~training_configuration_m training_configuration_m module~trainable_engine_m->module~training_configuration_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->julienne_string_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->julienne_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~network_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: trainable_engine_s module~~trainable_engine_m~~UsedByGraph module~trainable_engine_m trainable_engine_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Interfaces public        interface trainable_engine_t private impure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) private impure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( trainable_engine_t ) private module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_range, output_range) result(trainable_engine) Implementation → Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_range_t ) :: input_range type( tensor_range_t ) :: output_range Return Value type( trainable_engine_t ) interface private pure module subroutine assert_consistent(self) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self interface private elemental module function infer(self, inputs) result(outputs) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) interface private elemental module function map_from_input_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function map_from_output_training_range(self, tensor) result(unnormalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function map_to_input_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function map_to_output_training_range(self, tensor) result(normalized_tensor) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) interface private elemental module function num_inputs(self) result(n_in) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_layers(self) result(n_layers) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private elemental module function num_outputs(self) result(n_out) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer interface private module function to_inference_engine(self) result(inference_engine) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) interface private pure module subroutine train(self, mini_batches_arr, cost, adam, learning_rate) Implementation → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate Derived Types type, public :: trainable_engine_t Encapsulate the information needed to perform training Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: b (:,:) class( differentiable_activation_strategy_t ), private, allocatable :: differentiable_activation_strategy_ type( tensor_range_t ), private :: input_range_ type(string_t), private, allocatable :: metadata_ (:) integer, private, allocatable :: n (:) type( tensor_range_t ), private :: output_range_ real(kind=rkind), private, allocatable :: w (:,:,:) Constructor private\n\n                    impure, module\n                    function construct_from_inference_engine (inference_engine) private\n\n                    impure, module\n                    function construct_from_padded_arrays (nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) private\n\n                    module\n                    function perturbed_identity_network (training_configuration, perturbation_magnitude, metadata, input_range, output_range) Type-Bound Procedures procedure, public :: assert_consistent procedure, public :: infer procedure, public :: map_from_input_training_range procedure, public :: map_from_output_training_range procedure, public :: map_to_input_training_range procedure, public :: map_to_output_training_range procedure, public :: num_inputs procedure, public :: num_layers procedure, public :: num_outputs procedure, public :: to_inference_engine procedure, public :: train","tags":"","loc":"module/trainable_engine_m.html"},{"title":"activation_strategy_m – Inference-Engine","text":"Uses kind_parameters_m julienne_string_m module~~activation_strategy_m~~UsesGraph module~activation_strategy_m activation_strategy_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~activation_strategy_m~~UsedByGraph module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~step_m step_m module~inference_engine_m->module~step_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~step_m->module~activation_strategy_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~gelu_m->module~differentiable_activation_strategy_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~step_m module~inference_engine_s->module~gelu_m module~layer_m layer_m module~inference_engine_s->module~layer_m module~inference_engine_s->module~relu_m module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~layer_m->module~inference_engine_m_ module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~relu_m->module~differentiable_activation_strategy_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_m->module~differentiable_activation_strategy_m module~step_s step_s module~step_s->module~step_m module~swish_m->module~differentiable_activation_strategy_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~training_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~gelu_s gelu_s module~gelu_s->module~gelu_m module~layer_s layer_s module~layer_s->module~layer_m module~relu_s relu_s module~relu_s->module~relu_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Abstract Interfaces abstract interface public elemental function activation_i(x) result(y) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) abstract interface public elemental function function_name_i(self) result(string) Arguments Type Intent Optional Attributes Name class( activation_strategy_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, abstract :: activation_strategy_t Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation procedure( function_name_i ), public, deferred :: function_name","tags":"","loc":"module/activation_strategy_m.html"},{"title":"swish_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m julienne_string_m module~~swish_m~~UsesGraph module~swish_m swish_m julienne_string_m julienne_string_m module~swish_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: swish_s module~~swish_m~~UsedByGraph module~swish_m swish_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~swish_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~swish_m module~swish_s swish_s module~swish_s->module~swish_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: swish_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/swish_m.html"},{"title":"relu_m – Inference-Engine","text":"Uses differentiable_activation_strategy_m kind_parameters_m julienne_string_m module~~relu_m~~UsesGraph module~relu_m relu_m julienne_string_m julienne_string_m module~relu_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~relu_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: relu_s module~~relu_m~~UsedByGraph module~relu_m relu_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~relu_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~relu_m module~relu_s relu_s module~relu_s->module~relu_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface private elemental module function activation(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function activation_derivative(x) result(y) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) interface private elemental module function function_name(self) result(string) Implementation → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t) Derived Types type, public, extends( differentiable_activation_strategy_t ) :: relu_t Type-Bound Procedures procedure, public, nopass :: activation procedure, public, nopass :: activation_derivative procedure, public :: function_name","tags":"","loc":"module/relu_m.html"},{"title":"addition_m – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~addition_m~~UsesGraph module~addition_m addition_m assert_m assert_m module~addition_m->assert_m module~inference_engine_m inference_engine_m module~addition_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~addition_m~~UsedByGraph module~addition_m addition_m program~learn_addition learn_addition program~learn_addition->module~addition_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/addition_m.html"},{"title":"thompson_tensors_m – Inference-Engine","text":"This module supports the program in the file example/learn-microphysics-procedures.f90. Uses assert_m inference_engine_m module_mp_thompson module~~thompson_tensors_m~~UsesGraph module~thompson_tensors_m thompson_tensors_m assert_m assert_m module~thompson_tensors_m->assert_m module~inference_engine_m inference_engine_m module~thompson_tensors_m->module~inference_engine_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~thompson_tensors_m~~UsedByGraph module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public impure elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/thompson_tensors_m.html"},{"title":"saturated_mixing_ratio_m – Inference-Engine","text":"This module supports the program in the file example/learn-saturated-mixing-ratio.f90.\nThe saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function\nin the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90.\nICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. Uses assert_m inference_engine_m module~~saturated_mixing_ratio_m~~UsesGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m assert_m assert_m module~saturated_mixing_ratio_m->assert_m module~inference_engine_m inference_engine_m module~saturated_mixing_ratio_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~saturated_mixing_ratio_m~~UsedByGraph module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real, public, parameter :: T (*) = [(real(i)/real(resolution), i=0, resolution)] real, public, parameter :: p (*) = [(real(i)/real(resolution), i=0, resolution)] real, private, parameter :: T_max = 307.610779 real, private, parameter :: T_min = 236.352524 real, private, parameter :: freezing_threshold = 273.15 integer, private :: i real, private, parameter :: p_max = 98596.7578 real, private, parameter :: p_min = 29671.1348 integer, private, parameter :: resolution = 10 Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t ) private pure function saturated_mixing_ratio (T_normalized, p_normalized) result(sat_mr) Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) Arguments Type Intent Optional Attributes Name real, intent(in) :: T_normalized real, intent(in) :: p_normalized Return Value real","tags":"","loc":"module/saturated_mixing_ratio_m.html"},{"title":"module_mp_thompson – Inference-Engine","text":"Used by module~~module_mp_thompson~~UsedByGraph module~module_mp_thompson module_mp_thompson module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~module_mp_thompson program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~thompson_tensors_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function RSIF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real public  function RSLF (P, T) Arguments Type Intent Optional Attributes Name real, intent(in) :: P real, intent(in) :: T Return Value real","tags":"","loc":"module/module_mp_thompson.html"},{"title":"tensor_m – Inference-Engine","text":"Uses kind_parameters_m module~~tensor_m~~UsesGraph module~tensor_m tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: tensor_s module~~tensor_m~~UsedByGraph module~tensor_m tensor_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~tensor_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m module~input_output_pair_m->module~tensor_m module~tensor_range_m->module~tensor_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~trainable_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_m->module~inference_engine_m_ module~layer_m->module~tensor_range_m module~mini_batch_m->module~input_output_pair_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~tensor_range_s tensor_range_s module~tensor_range_s->module~tensor_range_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface tensor_t private pure module function construct_from_components(values) result(tensor) Implementation → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) interface private pure module function num_components(self) result(n) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer interface private pure module function values(self) result(tensor_values) Implementation → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:) Derived Types type, public :: tensor_t Components Type Visibility Attributes Name Initial real(kind=rkind), private, allocatable :: values_ (:) Constructor private\n\n                    pure, module\n                    function construct_from_components (values) Type-Bound Procedures procedure, public :: num_components procedure, public :: values","tags":"","loc":"module/tensor_m.html"},{"title":"multiply_inputs – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~multiply_inputs~~UsesGraph module~multiply_inputs multiply_inputs assert_m assert_m module~multiply_inputs->assert_m module~inference_engine_m inference_engine_m module~multiply_inputs->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~multiply_inputs~~UsedByGraph module~multiply_inputs multiply_inputs program~learn_multiplication learn_multiplication program~learn_multiplication->module~multiply_inputs Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_tensor) result(a_tensor) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_tensor Return Value type( tensor_t )","tags":"","loc":"module/multiply_inputs.html"},{"title":"power_series – Inference-Engine","text":"Define a function that produces the desired network output for a given network input Uses assert_m inference_engine_m module~~power_series~~UsesGraph module~power_series power_series assert_m assert_m module~power_series->assert_m module~inference_engine_m inference_engine_m module~power_series->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~power_series~~UsedByGraph module~power_series power_series program~learn_power_series learn_power_series program~learn_power_series->module~power_series Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public elemental function y (x_in) result(a) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: x_in Return Value type( tensor_t )","tags":"","loc":"module/power_series.html"},{"title":"ubounds_m – Inference-Engine","text":"This module serves only to support array bounds checking in the main program below Used by module~~ubounds_m~~UsedByGraph module~ubounds_m ubounds_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~ubounds_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: ubounds_t Components Type Visibility Attributes Name Initial integer, public, allocatable :: ubounds_ (:) Type-Bound Procedures procedure, public :: equals generic, public :: operator(==) => equals Functions public elemental function equals (lhs, rhs) result(lhs_equals_rhs) Arguments Type Intent Optional Attributes Name class( ubounds_t ), intent(in) :: lhs class( ubounds_t ), intent(in) :: rhs Return Value logical","tags":"","loc":"module/ubounds_m.html"},{"title":"differentiable_activation_strategy_m – Inference-Engine","text":"Uses activation_strategy_m module~~differentiable_activation_strategy_m~~UsesGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~differentiable_activation_strategy_m~~UsedByGraph module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~gelu_m gelu_m module~gelu_m->module~differentiable_activation_strategy_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m->module~gelu_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~swish_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~training_configuration_m module~training_configuration_m->module~differentiable_activation_strategy_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~gelu_s gelu_s module~gelu_s->module~gelu_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~gelu_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~relu_m module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~swish_m module~layer_m layer_m module~inference_engine_s->module~layer_m module~layer_m->module~inference_engine_m_ module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~relu_s relu_s module~relu_s->module~relu_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~layer_s layer_s module~layer_s->module~layer_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public, abstract, extends( activation_strategy_t ) :: differentiable_activation_strategy_t Type-Bound Procedures procedure( activation_i ), public, deferred, nopass :: activation procedure( activation_i ), public, deferred, nopass :: activation_derivative procedure( function_name_i ), public, deferred :: function_name","tags":"","loc":"module/differentiable_activation_strategy_m.html"},{"title":"training_configuration_m – Inference-Engine","text":"Uses kind_parameters_m network_configuration_m differentiable_activation_strategy_m julienne_file_m hyperparameters_m julienne_string_m module~~training_configuration_m~~UsesGraph module~training_configuration_m training_configuration_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~training_configuration_m->module~differentiable_activation_strategy_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~kind_parameters_m kind_parameters_m module~training_configuration_m->module~kind_parameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: training_configuration_s module~~training_configuration_m~~UsedByGraph module~training_configuration_m training_configuration_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~training_configuration_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~trainable_engine_m->module~training_configuration_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~training_configuration_m module~training_configuration_s->module~inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface training_configuration_t private module function from_components(hyperparameters, network_configuration) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) private module function from_file(file_object) result(training_configuration) Implementation → Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) interface private module function differentiable_activation_strategy(self) result(strategy) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable interface private elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical interface private elemental module function learning_rate(self) result(rate) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) interface private elemental module function mini_batches(self) result(num_mini_batches) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer interface private pure module function nodes_per_layer(self) result(nodes) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) interface private elemental module function optimizer_name(self) result(identifier) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) interface private elemental module function skip_connections(self) result(using_skip) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical interface private pure module function to_json(self) result(json_lines) Implementation → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:) Derived Types type, public, extends(file_t) :: training_configuration_t Components Type Visibility Attributes Name Initial type( hyperparameters_t ), private :: hyperparameters_ type( network_configuration_t ), private :: network_configuration_ Constructor private\n\n                    module\n                    function from_components (hyperparameters, network_configuration) private\n\n                    module\n                    function from_file (file_object) Type-Bound Procedures procedure, public :: differentiable_activation_strategy procedure, public :: equals procedure, public :: learning_rate procedure, public :: mini_batches procedure, public :: nodes_per_layer generic, public :: operator(==) => equals procedure, public :: optimizer_name procedure, public :: skip_connections procedure, public :: to_json","tags":"","loc":"module/training_configuration_m.html"},{"title":"kind_parameters_m – Inference-Engine","text":"Used by module~~kind_parameters_m~~UsedByGraph module~kind_parameters_m kind_parameters_m module~activation_strategy_m activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~gelu_m gelu_m module~gelu_m->module~kind_parameters_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_s gelu_s module~gelu_s->module~kind_parameters_m module~gelu_s->module~gelu_m module~hyperparameters_m hyperparameters_m module~hyperparameters_m->module~kind_parameters_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~kind_parameters_m module~inference_engine_m->module~activation_strategy_m module~inference_engine_m->module~gelu_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~inference_engine_m->module~differentiable_activation_strategy_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_range_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~layer_m layer_m module~layer_m->module~kind_parameters_m module~layer_m->module~inference_engine_m_ module~neuron_m neuron_m module~layer_m->module~neuron_m module~layer_m->module~tensor_range_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~neuron_m->module~kind_parameters_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_s relu_s module~relu_s->module~kind_parameters_m module~relu_s->module~relu_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_s step_s module~step_s->module~kind_parameters_m module~step_s->module~step_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~tensor_m->module~kind_parameters_m module~tensor_range_s tensor_range_s module~tensor_range_s->module~kind_parameters_m module~tensor_range_s->module~tensor_range_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~tensor_range_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~differentiable_activation_strategy_m program~write_read_infer write_read_infer program~write_read_infer->module~kind_parameters_m program~write_read_infer->module~inference_engine_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~hyperparameters_s hyperparameters_s module~hyperparameters_s->module~hyperparameters_m module~inference_engine_s inference_engine_s module~inference_engine_s->module~gelu_m module~inference_engine_s->module~inference_engine_m_ module~inference_engine_s->module~layer_m module~inference_engine_s->module~neuron_m module~inference_engine_s->module~relu_m module~inference_engine_s->module~sigmoid_m module~inference_engine_s->module~step_m module~inference_engine_s->module~swish_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~layer_s layer_s module~layer_s->module~layer_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~neuron_s neuron_s module~neuron_s->module~neuron_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~sigmoid_s sigmoid_s module~sigmoid_s->module~sigmoid_m module~swish_s swish_s module~swish_s->module~sigmoid_m module~swish_s->module~swish_m module~tensor_range_m->module~tensor_m module~tensor_s tensor_s module~tensor_s->module~tensor_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~tensor_m module~trainable_engine_s->module~trainable_engine_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m module~training_configuration_s->module~training_configuration_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: rkind = kind(1.0)","tags":"","loc":"module/kind_parameters_m.html"},{"title":"input_output_pair_m – Inference-Engine","text":"Uses tensor_m kind_parameters_m module~~input_output_pair_m~~UsesGraph module~input_output_pair_m input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: input_output_pair_s module~~input_output_pair_m~~UsedByGraph module~input_output_pair_m input_output_pair_m module~inference_engine_m inference_engine_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~input_output_pair_s input_output_pair_s module~input_output_pair_s->module~input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~addition_m addition_m module~addition_m->module~inference_engine_m module~exponentiation_m exponentiation_m module~exponentiation_m->module~inference_engine_m module~mini_batch_s mini_batch_s module~mini_batch_s->module~mini_batch_m module~multiply_inputs multiply_inputs module~multiply_inputs->module~inference_engine_m module~power_series power_series module~power_series->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m module~saturated_mixing_ratio_m->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m module~thompson_tensors_m->module~inference_engine_m module~trainable_engine_m->module~mini_batch_m module~training_configuration_s training_configuration_s module~training_configuration_s->module~inference_engine_m program~concurrent_inferences concurrent_inferences program~concurrent_inferences->module~inference_engine_m program~learn_addition learn_addition program~learn_addition->module~inference_engine_m program~learn_addition->module~addition_m program~learn_exponentiation learn_exponentiation program~learn_exponentiation->module~inference_engine_m program~learn_exponentiation->module~exponentiation_m program~learn_microphysics_procedures learn_microphysics_procedures program~learn_microphysics_procedures->module~inference_engine_m program~learn_microphysics_procedures->module~thompson_tensors_m program~learn_multiplication learn_multiplication program~learn_multiplication->module~inference_engine_m program~learn_multiplication->module~multiply_inputs program~learn_power_series learn_power_series program~learn_power_series->module~inference_engine_m program~learn_power_series->module~power_series program~print_training_configuration print_training_configuration program~print_training_configuration->module~inference_engine_m program~train_and_write train_and_write program~train_and_write->module~inference_engine_m program~train_saturated_mixture_ratio train_saturated_mixture_ratio program~train_saturated_mixture_ratio->module~inference_engine_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m program~write_read_infer write_read_infer program~write_read_infer->module~inference_engine_m module~trainable_engine_s trainable_engine_s module~trainable_engine_s->module~trainable_engine_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface input_output_pair_t private elemental module function construct(inputs, expected_outputs) result(input_output_pair) Implementation → Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) interface public module subroutine shuffle(pairs) Implementation → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:) interface private elemental module function expected_outputs(self) result(my_expected_outputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) interface private elemental module function inputs(self) result(my_inputs) Implementation → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) Derived Types type, public :: input_output_pair_t Components Type Visibility Attributes Name Initial type( tensor_t ), private :: expected_outputs_ type( tensor_t ), private :: inputs_ Constructor private\n\n                    elemental, module\n                    function construct (inputs, expected_outputs) Type-Bound Procedures procedure, public :: expected_outputs procedure, public :: inputs","tags":"","loc":"module/input_output_pair_m.html"},{"title":"inference_engine_s – Inference-Engine","text":"Uses neuron_m assert_m relu_m step_m julienne_formats_m gelu_m layer_m sigmoid_m swish_m Ancestors: inference_engine_m_ module~~inference_engine_s~~UsesGraph module~inference_engine_s inference_engine_s assert_m assert_m module~inference_engine_s->assert_m julienne_formats_m julienne_formats_m module~inference_engine_s->julienne_formats_m module~gelu_m gelu_m module~inference_engine_s->module~gelu_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_s->module~inference_engine_m_ module~layer_m layer_m module~inference_engine_s->module~layer_m module~neuron_m neuron_m module~inference_engine_s->module~neuron_m module~relu_m relu_m module~inference_engine_s->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_s->module~sigmoid_m module~step_m step_m module~inference_engine_s->module~step_m module~swish_m swish_m module~inference_engine_s->module~swish_m julienne_string_m julienne_string_m module~gelu_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~gelu_m->module~kind_parameters_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m_->module~tensor_range_m module~layer_m->module~inference_engine_m_ module~layer_m->module~neuron_m module~layer_m->julienne_string_m module~layer_m->module~kind_parameters_m module~layer_m->module~tensor_range_m module~neuron_m->julienne_string_m module~neuron_m->module~kind_parameters_m module~relu_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~step_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~swish_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces interface assert_consistency pure subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self pure subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self Subroutines pure subroutine difference_consistency (self) Arguments Type Intent Optional Attributes Name type( difference_t ), intent(in) :: self pure subroutine inference_engine_consistency (self) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: self impure subroutine set_activation_strategy (inference_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(inout) :: inference_engine Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html activation_function_name elemental module function activation_function_name(self) result(activation_name) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html assert_conformable_with elemental module subroutine assert_conformable_with(self, inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: inference_engine module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html construct_from_json impure elemental module function construct_from_json(file_) result(inference_engine) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_ Return Value type( inference_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html construct_from_padded_arrays impure module function construct_from_padded_arrays(metadata, weights, biases, nodes, input_range, output_range) result(inference_engine) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: metadata (:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) integer, intent(in) :: nodes (0:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( inference_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html infer elemental module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html map_from_output_range elemental module function map_from_output_range(self, normalized_tensor) result(tensor) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: normalized_tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html map_to_input_range elemental module function map_to_input_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html nodes_per_layer pure module function nodes_per_layer(self) result(node_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html norm elemental module function norm(self) result(norm_of_self) Interface → Arguments Type Intent Optional Attributes Name class( difference_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html num_inputs elemental module function num_inputs(self) result(input_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html num_outputs elemental module function num_outputs(self) result(output_count) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html skip pure module function skip(self) result(use_skip_connections) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html subtract elemental module function subtract(self, rhs) result(difference) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self type( inference_engine_t ), intent(in) :: rhs Return Value type( difference_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html to_exchange impure module function to_exchange(self) result(exchange) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type( exchange_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/inference_engine_s.html to_json impure elemental module function to_json(self) result(json_file) Interface → Arguments Type Intent Optional Attributes Name class( inference_engine_t ), intent(in) :: self Return Value type(file_t)","tags":"","loc":"module/inference_engine_s.html"},{"title":"trainable_engine_s – Inference-Engine","text":"Uses intrinsic_array_m assert_m tensor_m Ancestors: trainable_engine_m module~~trainable_engine_s~~UsesGraph module~trainable_engine_s trainable_engine_s assert_m assert_m module~trainable_engine_s->assert_m intrinsic_array_m intrinsic_array_m module~trainable_engine_s->intrinsic_array_m module~tensor_m tensor_m module~trainable_engine_s->module~tensor_m module~trainable_engine_m trainable_engine_m module~trainable_engine_s->module~trainable_engine_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m module~trainable_engine_m->module~tensor_m julienne_string_m julienne_string_m module~trainable_engine_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~inference_engine_m_ inference_engine_m_ module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~trainable_engine_m->module~mini_batch_m module~tensor_range_m tensor_range_m module~trainable_engine_m->module~tensor_range_m module~training_configuration_m training_configuration_m module~trainable_engine_m->module~training_configuration_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->julienne_string_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->module~activation_strategy_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->julienne_file_m module~hyperparameters_m hyperparameters_m module~training_configuration_m->module~hyperparameters_m module~network_configuration_m network_configuration_m module~training_configuration_m->module~network_configuration_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~input_output_pair_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: input_layer = 0 Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html assert_consistent pure module subroutine assert_consistent(self) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html construct_from_inference_engine impure module function construct_from_inference_engine(inference_engine) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine Return Value type( trainable_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html construct_from_padded_arrays impure module function construct_from_padded_arrays(nodes, weights, biases, differentiable_activation_strategy, metadata, input_range, output_range) result(trainable_engine) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nodes (input_layer:) real(kind=rkind), intent(in) :: weights (:,:,:) real(kind=rkind), intent(in) :: biases (:,:) class( differentiable_activation_strategy_t ), intent(in) :: differentiable_activation_strategy type(string_t), intent(in) :: metadata (:) type( tensor_range_t ), intent(in), optional :: input_range type( tensor_range_t ), intent(in), optional :: output_range Return Value type( trainable_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html infer elemental module function infer(self, inputs) result(outputs) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: inputs Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html map_from_input_training_range elemental module function map_from_input_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html map_from_output_training_range elemental module function map_from_output_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html map_to_input_training_range elemental module function map_to_input_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html map_to_output_training_range elemental module function map_to_output_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html num_inputs elemental module function num_inputs(self) result(n_in) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html num_layers elemental module function num_layers(self) result(n_layers) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html num_outputs elemental module function num_outputs(self) result(n_out) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html perturbed_identity_network module function perturbed_identity_network(training_configuration, perturbation_magnitude, metadata, input_range, output_range) result(trainable_engine) Arguments Type Intent Optional Attributes Name type( training_configuration_t ), intent(in) :: training_configuration real(kind=rkind), intent(in) :: perturbation_magnitude type(string_t), intent(in) :: metadata (:) type( tensor_range_t ) :: input_range type( tensor_range_t ) :: output_range Return Value type( trainable_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html to_inference_engine module function to_inference_engine(self) result(inference_engine) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(in) :: self Return Value type( inference_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/trainable_engine_s.html train pure module subroutine train(self, mini_batches_arr, cost, adam, learning_rate) Interface → Arguments Type Intent Optional Attributes Name class( trainable_engine_t ), intent(inout) :: self type( mini_batch_t ), intent(in) :: mini_batches_arr (:) real(kind=rkind), intent(out), optional, allocatable :: cost (:) logical, intent(in) :: adam real(kind=rkind), intent(in) :: learning_rate","tags":"","loc":"module/trainable_engine_s.html"},{"title":"gelu_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: gelu_m module~~gelu_s~~UsesGraph module~gelu_s gelu_s module~gelu_m gelu_m module~gelu_s->module~gelu_m module~kind_parameters_m kind_parameters_m module~gelu_s->module~kind_parameters_m module~gelu_m->module~kind_parameters_m julienne_string_m julienne_string_m module~gelu_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=rkind), private, parameter :: half = 0.5_rkind real(kind=rkind), private, parameter :: one = 1._rkind real(kind=rkind), private, parameter :: pi = 3.141592653589793_rkind real(kind=rkind), private, parameter :: sqrt_2 = sqrt(two) real(kind=rkind), private, parameter :: sqrt_2_pi = sqrt(two*pi) real(kind=rkind), private, parameter :: two = 2._rkind Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/gelu_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/gelu_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/gelu_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( gelu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/gelu_s.html"},{"title":"relu_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: relu_m module~~relu_s~~UsesGraph module~relu_s relu_s module~kind_parameters_m kind_parameters_m module~relu_s->module~kind_parameters_m module~relu_m relu_m module~relu_s->module~relu_m module~relu_m->module~kind_parameters_m julienne_string_m julienne_string_m module~relu_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~relu_m->module~differentiable_activation_strategy_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=rkind), private, parameter :: one = 1._rkind real(kind=rkind), private, parameter :: zero = 0._rkind Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/relu_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( relu_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/relu_s.html"},{"title":"sigmoid_s – Inference-Engine","text":"Uses Ancestors: sigmoid_m module~~sigmoid_s~~UsesGraph module~sigmoid_s sigmoid_s module~sigmoid_m sigmoid_m module~sigmoid_s->module~sigmoid_m julienne_string_m julienne_string_m module~sigmoid_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/sigmoid_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( sigmoid_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/sigmoid_s.html"},{"title":"layer_s – Inference-Engine","text":"Uses intrinsic_array_m assert_m Ancestors: layer_m module~~layer_s~~UsesGraph module~layer_s layer_s assert_m assert_m module~layer_s->assert_m intrinsic_array_m intrinsic_array_m module~layer_s->intrinsic_array_m module~layer_m layer_m module~layer_s->module~layer_m julienne_string_m julienne_string_m module~layer_m->julienne_string_m module~inference_engine_m_ inference_engine_m_ module~layer_m->module~inference_engine_m_ module~kind_parameters_m kind_parameters_m module~layer_m->module~kind_parameters_m module~neuron_m neuron_m module~layer_m->module~neuron_m module~tensor_range_m tensor_range_m module~layer_m->module~tensor_range_m module~inference_engine_m_->julienne_string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~activation_strategy_m activation_strategy_m module~inference_engine_m_->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~tensor_m tensor_m module~inference_engine_m_->module~tensor_m module~neuron_m->julienne_string_m module~neuron_m->module~kind_parameters_m julienne_m julienne_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html construct_layer recursive module function construct_layer(layer_lines, start) result(layer) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: layer_lines (:) integer, intent(in) :: start Return Value type( layer_t ), target module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html count_inputs module function count_inputs(layer) result(num_inputs) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html count_layers module function count_layers(layer) result(num_layers) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html count_neurons module function count_neurons(layer) result(neurons_per_layer_result) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: layer Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html inference_engine module function inference_engine(hidden_layers, metadata, output_layer, input_range, output_range) result(inference_engine_) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: hidden_layers type(string_t), intent(in) :: metadata (:) type( layer_t ), intent(in), target :: output_layer type( tensor_range_t ), intent(in) :: input_range type( tensor_range_t ), intent(in) :: output_range Return Value type( inference_engine_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html neurons_per_layer module function neurons_per_layer(self) result(num_neurons) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/layer_s.html next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( layer_t ), intent(in), target :: self Return Value type( layer_t ), pointer","tags":"","loc":"module/layer_s.html"},{"title":"neuron_s – Inference-Engine","text":"Uses assert_m Ancestors: neuron_m module~~neuron_s~~UsesGraph module~neuron_s neuron_s assert_m assert_m module~neuron_s->assert_m module~neuron_m neuron_m module~neuron_s->module~neuron_m julienne_string_m julienne_string_m module~neuron_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~neuron_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html bias module function bias(self) result(my_bias) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html construct pure recursive module function construct(neuron_lines, start) result(neuron) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: neuron_lines (:) integer, intent(in) :: start Return Value type( neuron_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html next_allocated module function next_allocated(self) result(next_is_allocated) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html next_pointer module function next_pointer(self) result(next_ptr) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in), target :: self Return Value type( neuron_t ), pointer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html num_inputs pure module function num_inputs(self) result(size_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/neuron_s.html weights module function weights(self) result(my_weights) Interface → Arguments Type Intent Optional Attributes Name class( neuron_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"module/neuron_s.html"},{"title":"tensor_range_s – Inference-Engine","text":"Uses julienne_m assert_m kind_parameters_m Ancestors: tensor_range_m module~~tensor_range_s~~UsesGraph module~tensor_range_s tensor_range_s assert_m assert_m module~tensor_range_s->assert_m julienne_m julienne_m module~tensor_range_s->julienne_m module~kind_parameters_m kind_parameters_m module~tensor_range_s->module~kind_parameters_m module~tensor_range_m tensor_range_m module~tensor_range_s->module~tensor_range_m module~tensor_range_m->julienne_m module~tensor_m tensor_m module~tensor_range_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: lhs class( tensor_range_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html from_components pure module function from_components(layer, minima, maxima) result(tensor_range) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: layer real, intent(in), dimension(:) :: minima real, intent(in), dimension(:) :: maxima Return Value type( tensor_range_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html from_json module function from_json(lines) result(tensor_range) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( tensor_range_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html in_range elemental module function in_range(self, tensor) result(is_in_range) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html map_from_training_range elemental module function map_from_training_range(self, tensor) result(unnormalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html map_to_training_range elemental module function map_to_training_range(self, tensor) result(normalized_tensor) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self type( tensor_t ), intent(in) :: tensor Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_range_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( tensor_range_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/tensor_range_s.html"},{"title":"network_configuration_s – Inference-Engine","text":"Uses assert_m julienne_formats_m Ancestors: network_configuration_m module~~network_configuration_s~~UsesGraph module~network_configuration_s network_configuration_s assert_m assert_m module~network_configuration_s->assert_m julienne_formats_m julienne_formats_m module~network_configuration_s->julienne_formats_m module~network_configuration_m network_configuration_m module~network_configuration_s->module~network_configuration_m julienne_string_m julienne_string_m module~network_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: activation_name_key = \"activation function\" character(len=*), private, parameter :: nodes_per_layer_key = \"nodes per layer\" character(len=*), private, parameter :: skip_connections_key = \"skip connections\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html activation_name elemental module function activation_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: lhs class( network_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_components pure module function from_components(skip_connections, nodes_per_layer, activation_name) result(network_configuration) Arguments Type Intent Optional Attributes Name logical, intent(in) :: skip_connections integer, intent(in) :: nodes_per_layer (:) character(len=*), intent(in) :: activation_name Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html from_json pure module function from_json(lines) result(network_configuration) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( network_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/network_configuration_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( network_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/network_configuration_s.html"},{"title":"input_output_pair_s – Inference-Engine","text":"Uses assert_m Ancestors: input_output_pair_m module~~input_output_pair_s~~UsesGraph module~input_output_pair_s input_output_pair_s assert_m assert_m module~input_output_pair_s->assert_m module~input_output_pair_m input_output_pair_m module~input_output_pair_s->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html construct elemental module function construct(inputs, expected_outputs) result(input_output_pair) Arguments Type Intent Optional Attributes Name type( tensor_t ), intent(in) :: inputs type( tensor_t ), intent(in) :: expected_outputs Return Value type( input_output_pair_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html expected_outputs elemental module function expected_outputs(self) result(my_expected_outputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html inputs elemental module function inputs(self) result(my_inputs) Interface → Arguments Type Intent Optional Attributes Name class( input_output_pair_t ), intent(in) :: self Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/input_output_pair_s.html shuffle module subroutine shuffle(pairs) Interface → Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(inout) :: pairs (:)","tags":"","loc":"module/input_output_pair_s.html"},{"title":"step_s – Inference-Engine","text":"Uses kind_parameters_m Ancestors: step_m module~~step_s~~UsesGraph module~step_s step_s module~kind_parameters_m kind_parameters_m module~step_s->module~kind_parameters_m module~step_m step_m module~step_s->module~step_m module~step_m->module~kind_parameters_m julienne_string_m julienne_string_m module~step_m->julienne_string_m module~activation_strategy_m activation_strategy_m module~step_m->module~activation_strategy_m module~activation_strategy_m->module~kind_parameters_m module~activation_strategy_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/step_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/step_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( step_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/step_s.html"},{"title":"swish_s – Inference-Engine","text":"Uses sigmoid_m Ancestors: swish_m module~~swish_s~~UsesGraph module~swish_s swish_s module~sigmoid_m sigmoid_m module~swish_s->module~sigmoid_m module~swish_m swish_m module~swish_s->module~swish_m julienne_string_m julienne_string_m module~sigmoid_m->julienne_string_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~sigmoid_m->module~differentiable_activation_strategy_m module~kind_parameters_m kind_parameters_m module~sigmoid_m->module~kind_parameters_m module~swish_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html activation elemental module function activation(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html activation_derivative elemental module function activation_derivative(x) result(y) Interface → Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: x Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/swish_s.html function_name elemental module function function_name(self) result(string) Interface → Arguments Type Intent Optional Attributes Name class( swish_t ), intent(in) :: self Return Value type(string_t)","tags":"","loc":"module/swish_s.html"},{"title":"tensor_s – Inference-Engine","text":"Uses Ancestors: tensor_m module~~tensor_s~~UsesGraph module~tensor_s tensor_s module~tensor_m tensor_m module~tensor_s->module~tensor_m module~kind_parameters_m kind_parameters_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html construct_from_components pure module function construct_from_components(values) result(tensor) Arguments Type Intent Optional Attributes Name real(kind=rkind), intent(in) :: values (:) Return Value type( tensor_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html num_components pure module function num_components(self) result(n) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/tensor_s.html values pure module function values(self) result(tensor_values) Interface → Arguments Type Intent Optional Attributes Name class( tensor_t ), intent(in) :: self Return Value real(kind=rkind), allocatable, (:)","tags":"","loc":"module/tensor_s.html"},{"title":"training_configuration_s – Inference-Engine","text":"Uses assert_m inference_engine_m Ancestors: training_configuration_m module~~training_configuration_s~~UsesGraph module~training_configuration_s training_configuration_s assert_m assert_m module~training_configuration_s->assert_m module~inference_engine_m inference_engine_m module~training_configuration_s->module~inference_engine_m module~training_configuration_m training_configuration_m module~training_configuration_s->module~training_configuration_m module~inference_engine_m->module~training_configuration_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m julienne_file_m julienne_file_m module~training_configuration_m->julienne_file_m julienne_string_m julienne_string_m module~training_configuration_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~activation_strategy_m->julienne_string_m module~activation_strategy_m->module~kind_parameters_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->julienne_string_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~step_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~swish_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->module~tensor_m julienne_m julienne_m module~tensor_range_m->julienne_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: footer = \"}\" character(len=*), private, parameter :: header = \"{\" character(len=*), private, parameter :: separator = \",\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html differentiable_activation_strategy module function differentiable_activation_strategy(self) result(strategy) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value class( differentiable_activation_strategy_t ), allocatable module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html equals elemental module function equals(lhs, rhs) result(lhs_eq_rhs) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: lhs class( training_configuration_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html from_components module function from_components(hyperparameters, network_configuration) result(training_configuration) Arguments Type Intent Optional Attributes Name type( hyperparameters_t ), intent(in) :: hyperparameters type( network_configuration_t ), intent(in) :: network_configuration Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html from_file module function from_file(file_object) result(training_configuration) Arguments Type Intent Optional Attributes Name type(file_t), intent(in) :: file_object Return Value type( training_configuration_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html nodes_per_layer pure module function nodes_per_layer(self) result(nodes) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value integer, allocatable, (:) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html skip_connections elemental module function skip_connections(self) result(using_skip) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/training_configuration_s.html to_json pure module function to_json(self) result(json_lines) Interface → Arguments Type Intent Optional Attributes Name class( training_configuration_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/training_configuration_s.html"},{"title":"mini_batch_s – Inference-Engine","text":"Uses Ancestors: mini_batch_m module~~mini_batch_s~~UsesGraph module~mini_batch_s mini_batch_s module~mini_batch_m mini_batch_m module~mini_batch_s->module~mini_batch_m module~input_output_pair_m input_output_pair_m module~mini_batch_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~mini_batch_m->module~kind_parameters_m module~input_output_pair_m->module~kind_parameters_m module~tensor_m tensor_m module~input_output_pair_m->module~tensor_m module~tensor_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html construct pure module function construct(input_output_pairs) result(mini_batch) Arguments Type Intent Optional Attributes Name type( input_output_pair_t ), intent(in) :: input_output_pairs (:) Return Value type( mini_batch_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/mini_batch_s.html input_output_pairs pure module function input_output_pairs(self) result(my_input_output_pairs) Interface → Arguments Type Intent Optional Attributes Name class( mini_batch_t ), intent(in) :: self Return Value type( input_output_pair_t ), allocatable, (:)","tags":"","loc":"module/mini_batch_s.html"},{"title":"hyperparameters_s – Inference-Engine","text":"Uses assert_m Ancestors: hyperparameters_m module~~hyperparameters_s~~UsesGraph module~hyperparameters_s hyperparameters_s assert_m assert_m module~hyperparameters_s->assert_m module~hyperparameters_m hyperparameters_m module~hyperparameters_s->module~hyperparameters_m julienne_string_m julienne_string_m module~hyperparameters_m->julienne_string_m module~kind_parameters_m kind_parameters_m module~hyperparameters_m->module~kind_parameters_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: learning_rate_key = \"learning rate\" character(len=*), private, parameter :: mini_batches_key = \"mini-batches\" character(len=*), private, parameter :: optimizer_key = \"optimizer\" Module Procedures module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html equals elemental module function equals(lhs, rhs) result(lhs_equals_rhs) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: lhs class( hyperparameters_t ), intent(in) :: rhs Return Value logical module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html from_components pure module function from_components(mini_batches, learning_rate, optimizer) result(hyperparameters) Arguments Type Intent Optional Attributes Name integer, intent(in) :: mini_batches real, intent(in) :: learning_rate character(len=*), intent(in) :: optimizer Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html from_json pure module function from_json(lines) result(hyperparameters) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: lines (:) Return Value type( hyperparameters_t ) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html learning_rate elemental module function learning_rate(self) result(rate) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value real(kind=rkind) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html mini_batches elemental module function mini_batches(self) result(num_mini_batches) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value integer module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html optimizer_name elemental module function optimizer_name(self) result(identifier) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t) module procedure /home/runner/work/inference-engine/inference-engine/doc/html/module/hyperparameters_s.html to_json pure module function to_json(self) result(lines) Interface → Arguments Type Intent Optional Attributes Name class( hyperparameters_t ), intent(in) :: self Return Value type(string_t), allocatable, (:)","tags":"","loc":"module/hyperparameters_s.html"},{"title":"learn_exponentiation – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m exponentiation_m program~~learn_exponentiation~~UsesGraph program~learn_exponentiation learn_exponentiation assert_m assert_m program~learn_exponentiation->assert_m julienne_m julienne_m program~learn_exponentiation->julienne_m module~exponentiation_m exponentiation_m program~learn_exponentiation->module~exponentiation_m module~inference_engine_m inference_engine_m program~learn_exponentiation->module~inference_engine_m module~exponentiation_m->assert_m module~exponentiation_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_exponentiation~~CallsGraph program~learn_exponentiation learn_exponentiation assert assert program~learn_exponentiation->assert bin_t bin_t program~learn_exponentiation->bin_t bins bins program~learn_exponentiation->bins cost cost program~learn_exponentiation->cost desired_outputs desired_outputs program~learn_exponentiation->desired_outputs first first program~learn_exponentiation->first flag_value flag_value program~learn_exponentiation->flag_value infer infer program~learn_exponentiation->infer input_output_pairs input_output_pairs program~learn_exponentiation->input_output_pairs inputs inputs program~learn_exponentiation->inputs interface~shuffle shuffle program~learn_exponentiation->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_exponentiation->intrinsic_array_t last last program~learn_exponentiation->last mini_batches mini_batches program~learn_exponentiation->mini_batches network_outputs network_outputs program~learn_exponentiation->network_outputs num_inputs num_inputs program~learn_exponentiation->num_inputs num_outputs num_outputs program~learn_exponentiation->num_outputs output_sizes output_sizes program~learn_exponentiation->output_sizes proc~output output program~learn_exponentiation->proc~output proc~perturbed_identity_network perturbed_identity_network program~learn_exponentiation->proc~perturbed_identity_network proc~y y program~learn_exponentiation->proc~y random_init random_init program~learn_exponentiation->random_init random_numbers random_numbers program~learn_exponentiation->random_numbers string string program~learn_exponentiation->string string_t string_t program~learn_exponentiation->string_t to_inference_engine to_inference_engine program~learn_exponentiation->to_inference_engine train train program~learn_exponentiation->train values values program~learn_exponentiation->values interface~to_json inference_engine_t%to_json proc~output->interface~to_json write_lines write_lines proc~output->write_lines proc~perturbed_identity_network->string_t proc~e e proc~perturbed_identity_network->proc~e proc~y->assert interface~values tensor_t%values proc~y->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_exponentiation.html"},{"title":"print_training_configuration – Inference-Engine","text":"Uses julienne_m inference_engine_m program~~print_training_configuration~~UsesGraph program~print_training_configuration print_training_configuration julienne_m julienne_m program~print_training_configuration->julienne_m module~inference_engine_m inference_engine_m program~print_training_configuration->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Demonstrate how to construct and print a training_configuration_t object Calls program~~print_training_configuration~~CallsGraph program~print_training_configuration print_training_configuration file_t file_t program~print_training_configuration->file_t interface~to_json~5 training_configuration_t%to_json program~print_training_configuration->interface~to_json~5 write_lines write_lines program~print_training_configuration->write_lines Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","loc":"program/print_training_configuration.html"},{"title":"learn_addition – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m addition_m program~~learn_addition~~UsesGraph program~learn_addition learn_addition assert_m assert_m program~learn_addition->assert_m julienne_m julienne_m program~learn_addition->julienne_m module~addition_m addition_m program~learn_addition->module~addition_m module~inference_engine_m inference_engine_m program~learn_addition->module~inference_engine_m module~addition_m->assert_m module~addition_m->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_addition~~CallsGraph program~learn_addition learn_addition assert assert program~learn_addition->assert bin_t bin_t program~learn_addition->bin_t bins bins program~learn_addition->bins cost cost program~learn_addition->cost desired_outputs desired_outputs program~learn_addition->desired_outputs first first program~learn_addition->first flag_value flag_value program~learn_addition->flag_value infer infer program~learn_addition->infer input_output_pairs input_output_pairs program~learn_addition->input_output_pairs inputs inputs program~learn_addition->inputs interface~shuffle shuffle program~learn_addition->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_addition->intrinsic_array_t last last program~learn_addition->last mini_batches mini_batches program~learn_addition->mini_batches network_outputs network_outputs program~learn_addition->network_outputs num_inputs num_inputs program~learn_addition->num_inputs num_outputs num_outputs program~learn_addition->num_outputs output_sizes output_sizes program~learn_addition->output_sizes proc~output~2 output program~learn_addition->proc~output~2 proc~perturbed_identity_network~3 perturbed_identity_network program~learn_addition->proc~perturbed_identity_network~3 proc~y~2 y program~learn_addition->proc~y~2 random_init random_init program~learn_addition->random_init random_numbers random_numbers program~learn_addition->random_numbers string string program~learn_addition->string string_t string_t program~learn_addition->string_t to_inference_engine to_inference_engine program~learn_addition->to_inference_engine train train program~learn_addition->train values values program~learn_addition->values interface~to_json inference_engine_t%to_json proc~output~2->interface~to_json write_lines write_lines proc~output~2->write_lines proc~perturbed_identity_network~3->string_t proc~e~2 e proc~perturbed_identity_network~3->proc~e~2 proc~y~2->assert interface~values tensor_t%values proc~y~2->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_addition.html"},{"title":"learn_multiplication – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m multiply_inputs program~~learn_multiplication~~UsesGraph program~learn_multiplication learn_multiplication assert_m assert_m program~learn_multiplication->assert_m julienne_m julienne_m program~learn_multiplication->julienne_m module~inference_engine_m inference_engine_m program~learn_multiplication->module~inference_engine_m module~multiply_inputs multiply_inputs program~learn_multiplication->module~multiply_inputs module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~multiply_inputs->assert_m module~multiply_inputs->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_multiplication~~CallsGraph program~learn_multiplication learn_multiplication assert assert program~learn_multiplication->assert bin_t bin_t program~learn_multiplication->bin_t bins bins program~learn_multiplication->bins cost cost program~learn_multiplication->cost desired_outputs desired_outputs program~learn_multiplication->desired_outputs first first program~learn_multiplication->first flag_value flag_value program~learn_multiplication->flag_value infer infer program~learn_multiplication->infer input_output_pairs input_output_pairs program~learn_multiplication->input_output_pairs inputs inputs program~learn_multiplication->inputs interface~shuffle shuffle program~learn_multiplication->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_multiplication->intrinsic_array_t last last program~learn_multiplication->last mini_batches mini_batches program~learn_multiplication->mini_batches network_outputs network_outputs program~learn_multiplication->network_outputs num_inputs num_inputs program~learn_multiplication->num_inputs num_outputs num_outputs program~learn_multiplication->num_outputs output_sizes output_sizes program~learn_multiplication->output_sizes proc~output~3 output program~learn_multiplication->proc~output~3 proc~perturbed_identity_network~4 perturbed_identity_network program~learn_multiplication->proc~perturbed_identity_network~4 proc~y~5 y program~learn_multiplication->proc~y~5 random_init random_init program~learn_multiplication->random_init random_numbers random_numbers program~learn_multiplication->random_numbers string string program~learn_multiplication->string string_t string_t program~learn_multiplication->string_t to_inference_engine to_inference_engine program~learn_multiplication->to_inference_engine train train program~learn_multiplication->train values values program~learn_multiplication->values interface~to_json inference_engine_t%to_json proc~output~3->interface~to_json write_lines write_lines proc~output~3->write_lines proc~perturbed_identity_network~4->string_t proc~e~3 e proc~perturbed_identity_network~4->proc~e~3 proc~y~5->assert interface~values tensor_t%values proc~y~5->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_multiplication.html"},{"title":"learn_power_series – Inference-Engine","text":"Uses power_series julienne_m assert_m inference_engine_m program~~learn_power_series~~UsesGraph program~learn_power_series learn_power_series assert_m assert_m program~learn_power_series->assert_m julienne_m julienne_m program~learn_power_series->julienne_m module~inference_engine_m inference_engine_m program~learn_power_series->module~inference_engine_m module~power_series power_series program~learn_power_series->module~power_series module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~power_series->assert_m module~power_series->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This trains a neural network to learn the following six polynomial functions of its eight inputs. Calls program~~learn_power_series~~CallsGraph program~learn_power_series learn_power_series assert assert program~learn_power_series->assert bin_t bin_t program~learn_power_series->bin_t bins bins program~learn_power_series->bins cost cost program~learn_power_series->cost desired_outputs desired_outputs program~learn_power_series->desired_outputs first first program~learn_power_series->first flag_value flag_value program~learn_power_series->flag_value infer infer program~learn_power_series->infer input_output_pairs input_output_pairs program~learn_power_series->input_output_pairs inputs inputs program~learn_power_series->inputs interface~shuffle shuffle program~learn_power_series->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_power_series->intrinsic_array_t last last program~learn_power_series->last mini_batches mini_batches program~learn_power_series->mini_batches network_outputs network_outputs program~learn_power_series->network_outputs num_inputs num_inputs program~learn_power_series->num_inputs num_outputs num_outputs program~learn_power_series->num_outputs output_sizes output_sizes program~learn_power_series->output_sizes proc~output~4 output program~learn_power_series->proc~output~4 proc~perturbed_identity_network~5 perturbed_identity_network program~learn_power_series->proc~perturbed_identity_network~5 proc~y~6 y program~learn_power_series->proc~y~6 random_init random_init program~learn_power_series->random_init random_numbers random_numbers program~learn_power_series->random_numbers string string program~learn_power_series->string string_t string_t program~learn_power_series->string_t to_inference_engine to_inference_engine program~learn_power_series->to_inference_engine train train program~learn_power_series->train values values program~learn_power_series->values white_noise white_noise program~learn_power_series->white_noise interface~to_json inference_engine_t%to_json proc~output~4->interface~to_json write_lines write_lines proc~output~4->write_lines proc~perturbed_identity_network~5->string_t proc~e~4 e proc~perturbed_identity_network~5->proc~e~4 proc~y~6->assert interface~values tensor_t%values proc~y~6->interface~values Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/learn_power_series.html"},{"title":"learn_microphysics_procedures – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m thompson_tensors_m iso_fortran_env program~~learn_microphysics_procedures~~UsesGraph program~learn_microphysics_procedures learn_microphysics_procedures assert_m assert_m program~learn_microphysics_procedures->assert_m iso_fortran_env iso_fortran_env program~learn_microphysics_procedures->iso_fortran_env julienne_m julienne_m program~learn_microphysics_procedures->julienne_m module~inference_engine_m inference_engine_m program~learn_microphysics_procedures->module~inference_engine_m module~thompson_tensors_m thompson_tensors_m program~learn_microphysics_procedures->module~thompson_tensors_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~thompson_tensors_m->assert_m module~thompson_tensors_m->module~inference_engine_m module~module_mp_thompson module_mp_thompson module~thompson_tensors_m->module~module_mp_thompson module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Train a neural network proxies for procedures in the Thompson microphysics model\nin of ICAR (https://github.com/BerkeleyLab/icar). Calls program~~learn_microphysics_procedures~~CallsGraph program~learn_microphysics_procedures learn_microphysics_procedures assert assert program~learn_microphysics_procedures->assert bin_t bin_t program~learn_microphysics_procedures->bin_t bins bins program~learn_microphysics_procedures->bins cost cost program~learn_microphysics_procedures->cost desired_outputs desired_outputs program~learn_microphysics_procedures->desired_outputs file_t file_t program~learn_microphysics_procedures->file_t first first program~learn_microphysics_procedures->first flag_value flag_value program~learn_microphysics_procedures->flag_value infer infer program~learn_microphysics_procedures->infer input_output_pairs input_output_pairs program~learn_microphysics_procedures->input_output_pairs inputs inputs program~learn_microphysics_procedures->inputs interface~shuffle shuffle program~learn_microphysics_procedures->interface~shuffle intrinsic_array_t intrinsic_array_t program~learn_microphysics_procedures->intrinsic_array_t last last program~learn_microphysics_procedures->last mini_batches mini_batches program~learn_microphysics_procedures->mini_batches network_outputs network_outputs program~learn_microphysics_procedures->network_outputs nodes_per_layer nodes_per_layer program~learn_microphysics_procedures->nodes_per_layer num_inputs num_inputs program~learn_microphysics_procedures->num_inputs num_outputs num_outputs program~learn_microphysics_procedures->num_outputs output_sizes output_sizes program~learn_microphysics_procedures->output_sizes proc~open_plot_file_for_appending open_plot_file_for_appending program~learn_microphysics_procedures->proc~open_plot_file_for_appending proc~output~5 output program~learn_microphysics_procedures->proc~output~5 proc~perturbed_identity_network~6 perturbed_identity_network program~learn_microphysics_procedures->proc~perturbed_identity_network~6 proc~print_diagnostics print_diagnostics program~learn_microphysics_procedures->proc~print_diagnostics proc~y~3 y program~learn_microphysics_procedures->proc~y~3 random_init random_init program~learn_microphysics_procedures->random_init random_numbers random_numbers program~learn_microphysics_procedures->random_numbers string string program~learn_microphysics_procedures->string string_t string_t program~learn_microphysics_procedures->string_t to_inference_engine to_inference_engine program~learn_microphysics_procedures->to_inference_engine train train program~learn_microphysics_procedures->train values values program~learn_microphysics_procedures->values proc~open_plot_file_for_appending->file_t proc~open_plot_file_for_appending->string proc~open_plot_file_for_appending->string_t lines lines proc~open_plot_file_for_appending->lines interface~to_json inference_engine_t%to_json proc~output~5->interface~to_json write_lines write_lines proc~output~5->write_lines proc~perturbed_identity_network~6->string_t proc~e~5 e proc~perturbed_identity_network~6->proc~e~5 proc~y~3->assert interface~values tensor_t%values proc~y~3->interface~values proc~rsif RSIF proc~y~3->proc~rsif proc~rslf RSLF proc~y~3->proc~rslf Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/learn_microphysics_procedures.html"},{"title":"train_and_write – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m program~~train_and_write~~UsesGraph program~train_and_write train_and_write assert_m assert_m program~train_and_write->assert_m julienne_m julienne_m program~train_and_write->julienne_m module~inference_engine_m inference_engine_m program~train_and_write->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to train a simple neural network starting from a randomized initial condition and \nhow to write the initial network and the trained network to separate JSON files.  The network has two hiden layers.\nThe input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match\nthe corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions,\nthe desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere.\nThe initial condition corresponds to the desired network with all weights and biases perturbed by a random variable\nthat is uniformly distributed on the range [0,0.1]. Calls program~~train_and_write~~CallsGraph program~train_and_write train_and_write assert assert program~train_and_write->assert bin_t bin_t program~train_and_write->bin_t bins bins program~train_and_write->bins cost cost program~train_and_write->cost first first program~train_and_write->first flag_value flag_value program~train_and_write->flag_value infer infer program~train_and_write->infer input_output_pairs input_output_pairs program~train_and_write->input_output_pairs inputs inputs program~train_and_write->inputs interface~shuffle shuffle program~train_and_write->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_and_write->intrinsic_array_t last last program~train_and_write->last mini_batches mini_batches program~train_and_write->mini_batches network_outputs network_outputs program~train_and_write->network_outputs num_inputs num_inputs program~train_and_write->num_inputs num_outputs num_outputs program~train_and_write->num_outputs proc~output~6 output program~train_and_write->proc~output~6 proc~perturbed_identity_network~7 perturbed_identity_network program~train_and_write->proc~perturbed_identity_network~7 random_init random_init program~train_and_write->random_init random_numbers random_numbers program~train_and_write->random_numbers string string program~train_and_write->string string_t string_t program~train_and_write->string_t to_inference_engine to_inference_engine program~train_and_write->to_inference_engine train train program~train_and_write->train values values program~train_and_write->values interface~to_json inference_engine_t%to_json proc~output~6->interface~to_json write_lines write_lines proc~output~6->write_lines proc~perturbed_identity_network~7->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: final_network_file Functions function perturbed_identity_network (perturbation_magnitude) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude Return Value type( trainable_engine_t ) Subroutines subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name","tags":"","loc":"program/train_and_write.html"},{"title":"concurrent_inferences – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m iso_fortran_env program~~concurrent_inferences~~UsesGraph program~concurrent_inferences concurrent_inferences assert_m assert_m program~concurrent_inferences->assert_m iso_fortran_env iso_fortran_env program~concurrent_inferences->iso_fortran_env julienne_m julienne_m program~concurrent_inferences->julienne_m module~inference_engine_m inference_engine_m program~concurrent_inferences->module~inference_engine_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to read a neural network from a JSON file\nand use the network to perform concurrent inferences. Calls program~~concurrent_inferences~~CallsGraph program~concurrent_inferences concurrent_inferences assert assert program~concurrent_inferences->assert file_t file_t program~concurrent_inferences->file_t flag_value flag_value program~concurrent_inferences->flag_value infer infer program~concurrent_inferences->infer input_components input_components program~concurrent_inferences->input_components inputs inputs program~concurrent_inferences->inputs num_inputs num_inputs program~concurrent_inferences->num_inputs outputs outputs program~concurrent_inferences->outputs string string program~concurrent_inferences->string string_t string_t program~concurrent_inferences->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: network_file_name","tags":"","loc":"program/concurrent_inferences.html"},{"title":"train_saturated_mixture_ratio – Inference-Engine","text":"Uses julienne_m assert_m inference_engine_m saturated_mixing_ratio_m iso_fortran_env program~~train_saturated_mixture_ratio~~UsesGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert_m assert_m program~train_saturated_mixture_ratio->assert_m iso_fortran_env iso_fortran_env program~train_saturated_mixture_ratio->iso_fortran_env julienne_m julienne_m program~train_saturated_mixture_ratio->julienne_m module~inference_engine_m inference_engine_m program~train_saturated_mixture_ratio->module~inference_engine_m module~saturated_mixing_ratio_m saturated_mixing_ratio_m program~train_saturated_mixture_ratio->module~saturated_mixing_ratio_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~kind_parameters_m kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~saturated_mixing_ratio_m->assert_m module~saturated_mixing_ratio_m->module~inference_engine_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~input_output_pair_m module~mini_batch_m->module~kind_parameters_m module~network_configuration_m->julienne_string_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->module~kind_parameters_m module~relu_m->julienne_string_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->julienne_string_m module~step_m->module~activation_strategy_m module~step_m->module~kind_parameters_m module~step_m->julienne_string_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->module~kind_parameters_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program trains a neural network to learn the saturated mixing ratio function of ICAR. Calls program~~train_saturated_mixture_ratio~~CallsGraph program~train_saturated_mixture_ratio train_saturated_mixture_ratio assert assert program~train_saturated_mixture_ratio->assert bin_t bin_t program~train_saturated_mixture_ratio->bin_t bins bins program~train_saturated_mixture_ratio->bins cost cost program~train_saturated_mixture_ratio->cost desired_outputs desired_outputs program~train_saturated_mixture_ratio->desired_outputs file_t file_t program~train_saturated_mixture_ratio->file_t first first program~train_saturated_mixture_ratio->first flag_value flag_value program~train_saturated_mixture_ratio->flag_value infer infer program~train_saturated_mixture_ratio->infer input_output_pairs input_output_pairs program~train_saturated_mixture_ratio->input_output_pairs inputs inputs program~train_saturated_mixture_ratio->inputs interface~shuffle shuffle program~train_saturated_mixture_ratio->interface~shuffle intrinsic_array_t intrinsic_array_t program~train_saturated_mixture_ratio->intrinsic_array_t last last program~train_saturated_mixture_ratio->last mini_batches mini_batches program~train_saturated_mixture_ratio->mini_batches network_outputs network_outputs program~train_saturated_mixture_ratio->network_outputs nodes_per_layer nodes_per_layer program~train_saturated_mixture_ratio->nodes_per_layer num_inputs num_inputs program~train_saturated_mixture_ratio->num_inputs num_outputs num_outputs program~train_saturated_mixture_ratio->num_outputs output_sizes output_sizes program~train_saturated_mixture_ratio->output_sizes proc~open_plot_file_for_appending~2 open_plot_file_for_appending program~train_saturated_mixture_ratio->proc~open_plot_file_for_appending~2 proc~output~7 output program~train_saturated_mixture_ratio->proc~output~7 proc~perturbed_identity_network~8 perturbed_identity_network program~train_saturated_mixture_ratio->proc~perturbed_identity_network~8 proc~print_diagnostics~2 print_diagnostics program~train_saturated_mixture_ratio->proc~print_diagnostics~2 proc~y~4 y program~train_saturated_mixture_ratio->proc~y~4 random_init random_init program~train_saturated_mixture_ratio->random_init random_numbers random_numbers program~train_saturated_mixture_ratio->random_numbers string string program~train_saturated_mixture_ratio->string string_t string_t program~train_saturated_mixture_ratio->string_t to_inference_engine to_inference_engine program~train_saturated_mixture_ratio->to_inference_engine train train program~train_saturated_mixture_ratio->train values values program~train_saturated_mixture_ratio->values proc~open_plot_file_for_appending~2->file_t proc~open_plot_file_for_appending~2->string proc~open_plot_file_for_appending~2->string_t lines lines proc~open_plot_file_for_appending~2->lines interface~to_json inference_engine_t%to_json proc~output~7->interface~to_json write_lines write_lines proc~output~7->write_lines proc~perturbed_identity_network~8->string_t proc~e~6 e proc~perturbed_identity_network~8->proc~e~6 proc~y~4->assert interface~values tensor_t%values proc~y~4->interface~values proc~saturated_mixing_ratio saturated_mixing_ratio proc~y~4->proc~saturated_mixing_ratio Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial integer(kind=int64) :: clock_rate type(command_line_t) :: command_line integer(kind=int64) :: counter_end integer(kind=int64) :: counter_start type(string_t) :: network_file Functions pure function e (j, n) result(unit_vector) Arguments Type Intent Optional Attributes Name integer, intent(in) :: j integer, intent(in) :: n Return Value real, allocatable, (:) function perturbed_identity_network (perturbation_magnitude, n) result(trainable_engine) Arguments Type Intent Optional Attributes Name real, intent(in) :: perturbation_magnitude integer, intent(in) :: n (:) Return Value type( trainable_engine_t ) Subroutines subroutine open_plot_file_for_appending (plot_file_name, plot_unit, previous_epoch, previous_clock) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: plot_file_name integer, intent(out) :: plot_unit integer, intent(out) :: previous_epoch real, intent(out) :: previous_clock subroutine output (inference_engine, file_name) Arguments Type Intent Optional Attributes Name type( inference_engine_t ), intent(in) :: inference_engine type(string_t), intent(in) :: file_name subroutine print_diagnostics (plot_file_unit, epoch, cost, clock, nodes) Arguments Type Intent Optional Attributes Name integer, intent(in) :: plot_file_unit integer, intent(in) :: epoch real, intent(in) :: cost real, intent(in) :: clock integer, intent(in) :: nodes (:)","tags":"","loc":"program/train_saturated_mixture_ratio.html"},{"title":"write_read_infer – Inference-Engine","text":"Uses julienne_m inference_engine_m kind_parameters_m program~~write_read_infer~~UsesGraph program~write_read_infer write_read_infer julienne_m julienne_m program~write_read_infer->julienne_m module~inference_engine_m inference_engine_m program~write_read_infer->module~inference_engine_m module~kind_parameters_m kind_parameters_m program~write_read_infer->module~kind_parameters_m module~inference_engine_m->module~kind_parameters_m module~activation_strategy_m activation_strategy_m module~inference_engine_m->module~activation_strategy_m module~differentiable_activation_strategy_m differentiable_activation_strategy_m module~inference_engine_m->module~differentiable_activation_strategy_m module~gelu_m gelu_m module~inference_engine_m->module~gelu_m module~hyperparameters_m hyperparameters_m module~inference_engine_m->module~hyperparameters_m module~inference_engine_m_ inference_engine_m_ module~inference_engine_m->module~inference_engine_m_ module~input_output_pair_m input_output_pair_m module~inference_engine_m->module~input_output_pair_m module~mini_batch_m mini_batch_m module~inference_engine_m->module~mini_batch_m module~network_configuration_m network_configuration_m module~inference_engine_m->module~network_configuration_m module~relu_m relu_m module~inference_engine_m->module~relu_m module~sigmoid_m sigmoid_m module~inference_engine_m->module~sigmoid_m module~step_m step_m module~inference_engine_m->module~step_m module~swish_m swish_m module~inference_engine_m->module~swish_m module~tensor_m tensor_m module~inference_engine_m->module~tensor_m module~tensor_range_m tensor_range_m module~inference_engine_m->module~tensor_range_m module~trainable_engine_m trainable_engine_m module~inference_engine_m->module~trainable_engine_m module~training_configuration_m training_configuration_m module~inference_engine_m->module~training_configuration_m module~ubounds_m ubounds_m module~inference_engine_m->module~ubounds_m module~activation_strategy_m->module~kind_parameters_m julienne_string_m julienne_string_m module~activation_strategy_m->julienne_string_m module~differentiable_activation_strategy_m->module~activation_strategy_m module~gelu_m->module~kind_parameters_m module~gelu_m->module~differentiable_activation_strategy_m module~gelu_m->julienne_string_m module~hyperparameters_m->module~kind_parameters_m module~hyperparameters_m->julienne_string_m module~inference_engine_m_->module~kind_parameters_m module~inference_engine_m_->module~activation_strategy_m module~inference_engine_m_->module~differentiable_activation_strategy_m module~inference_engine_m_->module~tensor_m module~inference_engine_m_->module~tensor_range_m julienne_file_m julienne_file_m module~inference_engine_m_->julienne_file_m module~inference_engine_m_->julienne_string_m module~input_output_pair_m->module~kind_parameters_m module~input_output_pair_m->module~tensor_m module~mini_batch_m->module~kind_parameters_m module~mini_batch_m->module~input_output_pair_m module~network_configuration_m->julienne_string_m module~relu_m->module~kind_parameters_m module~relu_m->module~differentiable_activation_strategy_m module~relu_m->julienne_string_m module~sigmoid_m->module~kind_parameters_m module~sigmoid_m->module~differentiable_activation_strategy_m module~sigmoid_m->julienne_string_m module~step_m->module~kind_parameters_m module~step_m->module~activation_strategy_m module~step_m->julienne_string_m module~swish_m->module~kind_parameters_m module~swish_m->module~differentiable_activation_strategy_m module~swish_m->julienne_string_m module~tensor_m->module~kind_parameters_m module~tensor_range_m->julienne_m module~tensor_range_m->module~tensor_m module~trainable_engine_m->module~kind_parameters_m module~trainable_engine_m->module~differentiable_activation_strategy_m module~trainable_engine_m->module~inference_engine_m_ module~trainable_engine_m->module~mini_batch_m module~trainable_engine_m->module~tensor_m module~trainable_engine_m->module~tensor_range_m module~trainable_engine_m->module~training_configuration_m module~trainable_engine_m->julienne_string_m module~training_configuration_m->module~kind_parameters_m module~training_configuration_m->module~differentiable_activation_strategy_m module~training_configuration_m->module~hyperparameters_m module~training_configuration_m->module~network_configuration_m module~training_configuration_m->julienne_file_m module~training_configuration_m->julienne_string_m Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. This program demonstrates how to write a neural network to a JSON file,\nread the same network from the written file, query the network object for\nsome of its properties, print those properties, and use the network to\nperform inference.  The network performs an identity mapping from any\nnon-negative inputs to the corresponding outputs using a RELU activation\nfunction. Calls program~~write_read_infer~~CallsGraph program~write_read_infer write_read_infer flag_value flag_value program~write_read_infer->flag_value proc~write_read_query_infer write_read_query_infer program~write_read_infer->proc~write_read_query_infer string string program~write_read_infer->string string_t string_t program~write_read_infer->string_t proc~write_read_query_infer->string file_t file_t proc~write_read_query_infer->file_t interface~activation_function_name inference_engine_t%activation_function_name proc~write_read_query_infer->interface~activation_function_name interface~infer inference_engine_t%infer proc~write_read_query_infer->interface~infer interface~nodes_per_layer inference_engine_t%nodes_per_layer proc~write_read_query_infer->interface~nodes_per_layer interface~num_inputs inference_engine_t%num_inputs proc~write_read_query_infer->interface~num_inputs interface~num_outputs inference_engine_t%num_outputs proc~write_read_query_infer->interface~num_outputs interface~to_json inference_engine_t%to_json proc~write_read_query_infer->interface~to_json interface~values tensor_t%values proc~write_read_query_infer->interface~values proc~identity_network identity_network proc~write_read_query_infer->proc~identity_network write_lines write_lines proc~write_read_query_infer->write_lines proc~identity_network->string_t Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type(command_line_t) :: command_line type(string_t) :: file_name Functions function identity_network () result(inference_engine) Arguments None Return Value type( inference_engine_t ) Subroutines subroutine write_read_query_infer (output_file_name) Arguments Type Intent Optional Attributes Name type(string_t), intent(in) :: output_file_name","tags":"","loc":"program/write_read_infer.html"},{"title":"sigmoid_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_m.f90~~EfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~sigmoid_m.f90~~AfferentGraph sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module sigmoid_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: sigmoid_t type , extends ( differentiable_activation_strategy_t ) :: sigmoid_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( sigmoid_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module sigmoid_m","tags":"","loc":"sourcefile/sigmoid_m.f90.html"},{"title":"inference_engine_m_.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m_.f90~~EfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~inference_engine_m_.f90~~AfferentGraph sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m_ !! Define an abstraction that supports inference operationsn on a neural network use activation_strategy_m , only : activation_strategy_t use julienne_file_m , only : file_t use julienne_string_m , only : string_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use tensor_range_m , only : tensor_range_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: inference_engine_t public :: difference_t public :: exchange_t public :: infer character ( len =* ), parameter :: key ( * ) = [ character ( len = len ( \"usingSkipConnections\" )) :: & \"modelName\" , \"modelAuthor\" , \"compilationDate\" , \"activationFunction\" , \"usingSkipConnections\" ] type inference_engine_t !! Encapsulate the minimal information needed to perform inference !private type ( tensor_range_t ) input_range_ , output_range_ type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation contains procedure :: infer procedure :: to_json procedure :: map_to_input_range procedure :: map_from_output_range procedure :: num_inputs procedure :: num_outputs procedure :: nodes_per_layer procedure :: assert_conformable_with procedure :: skip procedure , private :: subtract generic :: operator ( - ) => subtract procedure :: activation_function_name procedure :: to_exchange end type type exchange_t type ( tensor_range_t ) input_range_ , output_range_ type ( string_t ) metadata_ ( size ( key )) real ( rkind ), allocatable :: weights_ (:,:,:), biases_ (:,:) integer , allocatable :: nodes_ (:) class ( activation_strategy_t ), allocatable :: activation_strategy_ ! Strategy Pattern facilitates elemental activation end type type difference_t private real ( rkind ), allocatable :: weights_difference_ (:,:,:), biases_difference_ (:,:) integer , allocatable :: nodes_difference_ (:) contains procedure :: norm end type interface inference_engine_t impure module function construct_from_padded_arrays ( metadata , weights , biases , nodes , input_range , output_range ) & result ( inference_engine ) implicit none type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) integer , intent ( in ) :: nodes ( 0 :) type ( tensor_range_t ), intent ( in ), optional :: input_range , output_range type ( inference_engine_t ) inference_engine end function impure elemental module function construct_from_json ( file_ ) result ( inference_engine ) implicit none type ( file_t ), intent ( in ) :: file_ type ( inference_engine_t ) inference_engine end function end interface interface elemental module function map_to_input_range ( self , tensor ) result ( normalized_tensor ) !! The result contains the input tensor values normalized to fall on the range used during training implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function map_from_output_range ( self , normalized_tensor ) result ( tensor ) !! The result contains the output tensor values unnormalized via the inverse of the mapping used in training implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: normalized_tensor type ( tensor_t ) tensor end function impure module function to_exchange ( self ) result ( exchange ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( exchange_t ) exchange end function impure elemental module function to_json ( self ) result ( json_file ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( file_t ) json_file end function elemental module function norm ( self ) result ( norm_of_self ) implicit none class ( difference_t ), intent ( in ) :: self real ( rkind ) norm_of_self end function elemental module function subtract ( self , rhs ) result ( difference ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: rhs type ( difference_t ) difference end function elemental module subroutine assert_conformable_with ( self , inference_engine ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( inference_engine_t ), intent ( in ) :: inference_engine end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_outputs ( self ) result ( output_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer output_count end function elemental module function num_inputs ( self ) result ( input_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer input_count end function pure module function nodes_per_layer ( self ) result ( node_count ) implicit none class ( inference_engine_t ), intent ( in ) :: self integer , allocatable :: node_count (:) end function elemental module function activation_function_name ( self ) result ( activation_name ) implicit none class ( inference_engine_t ), intent ( in ) :: self type ( string_t ) activation_name end function pure module function skip ( self ) result ( use_skip_connections ) implicit none class ( inference_engine_t ), intent ( in ) :: self logical use_skip_connections end function end interface end module inference_engine_m_","tags":"","loc":"sourcefile/inference_engine_m_.f90.html"},{"title":"inference_engine_s.F90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_s.f90~~EfferentGraph sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( inference_engine_m_ ) inference_engine_s use assert_m , only : assert , intrinsic_array_t use step_m , only : step_t use swish_m , only : swish_t use sigmoid_m , only : sigmoid_t use gelu_m , only : gelu_t use relu_m , only : relu_t use layer_m , only : layer_t use neuron_m , only : neuron_t use julienne_formats_m , only : separated_values implicit none interface assert_consistency procedure inference_engine_consistency procedure difference_consistency end interface contains module procedure map_to_input_range normalized_tensor = self % input_range_ % map_to_training_range ( tensor ) end procedure module procedure map_from_output_range tensor = self % output_range_ % map_from_training_range ( normalized_tensor ) end procedure module procedure to_exchange exchange % input_range_ = self % input_range_ exchange % output_range_ = self % output_range_ exchange % metadata_ = self % metadata_ exchange % weights_ = self % weights_ exchange % biases_ = self % biases_ exchange % nodes_ = self % nodes_ exchange % activation_strategy_ = self % activation_strategy_ end procedure module procedure infer real ( rkind ), allocatable :: a (:,:) integer , parameter :: input_layer = 0 integer k , l call assert_consistency ( self ) associate ( w => self % weights_ , b => self % biases_ , n => self % nodes_ , output_layer => ubound ( self % nodes_ , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) #ifndef _CRAYFTN associate ( normalized_inputs => self % input_range_ % map_to_training_range ( inputs )) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end associate #else block type ( tensor_t ) normalized_inputs normalized_inputs = self % input_range_ % map_to_training_range ( inputs ) a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () end block #endif feed_forward : & do l = input_layer + 1 , output_layer associate ( z => matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l )) a ( 1 : n ( l ), l ) = self % activation_strategy_ % activation ( z ) end associate end do feed_forward #ifdef _CRAYFTN block type ( tensor_t ) :: normalized_outputs normalized_outputs = tensor_t ( a ( 1 : n ( output_layer ), output_layer )) #else associate ( normalized_outputs => tensor_t ( a ( 1 : n ( output_layer ), output_layer ))) #endif outputs = self % output_range_ % map_from_training_range ( normalized_outputs ) #ifdef _CRAYFTN end block #else end associate #endif end associate end procedure pure subroutine inference_engine_consistency ( self ) type ( inference_engine_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_ ), allocated ( self % biases_ ), allocated ( self % nodes_ ), allocated ( self % activation_strategy_ )]& ) call assert ( all ( all_allocated ), \"inference_engine_s(inference_engine_consistency): fully_allocated\" , & intrinsic_array_t ( all_allocated )) end associate associate ( max_width => maxval ( self % nodes_ ), component_dims => [ size ( self % biases_ , 1 ), size ( self % weights_ , 1 ), size ( self % weights_ , 2 )]) call assert ( all ( component_dims == max_width ), \"inference_engine_s(inference_engine_consistency): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate associate ( input_subscript => lbound ( self % nodes_ , 1 )) call assert ( input_subscript == input_layer , \"inference_engine_s(inference_engine_consistency): n base subsscript\" , & input_subscript ) end associate end subroutine pure subroutine difference_consistency ( self ) type ( difference_t ), intent ( in ) :: self integer , parameter :: input_layer = 0 associate ( & all_allocated => [ allocated ( self % weights_difference_ ), allocated ( self % biases_difference_ ), allocated ( self % nodes_difference_ )] & ) call assert ( all ( all_allocated ), \"inference_engine_s(difference_consistency): fully_allocated\" , intrinsic_array_t ( all_allocated )) end associate call assert ( all ( size ( self % biases_difference_ , 1 ) == [ size ( self % weights_difference_ , 1 ), size ( self % weights_difference_ , 2 )]), & \"inference_engine_s(difference_consistency): conformable arrays\" & ) end subroutine impure subroutine set_activation_strategy ( inference_engine ) type ( inference_engine_t ), intent ( inout ) :: inference_engine character ( len = :), allocatable :: function_name function_name = inference_engine % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () select case ( function_name ) case ( \"swish\" ) inference_engine % activation_strategy_ = swish_t () case ( \"sigmoid\" ) inference_engine % activation_strategy_ = sigmoid_t () case ( \"step\" ) inference_engine % activation_strategy_ = step_t () case ( \"gelu\" ) inference_engine % activation_strategy_ = gelu_t () case ( \"relu\" ) inference_engine % activation_strategy_ = relu_t () case default error stop \"inference_engine_s(set_activation_strategy): unrecognized activation strategy '\" // function_name // \"'\" end select end subroutine module procedure construct_from_padded_arrays inference_engine % metadata_ = metadata inference_engine % weights_ = weights inference_engine % biases_ = biases inference_engine % nodes_ = nodes block integer i if ( present ( input_range )) then inference_engine % input_range_ = input_range else associate ( num_inputs => nodes ( lbound ( nodes , 1 ))) associate ( default_minima => [( 0. , i = 1 , num_inputs )], default_maxima => [( 1. , i = 1 , num_inputs )]) inference_engine % input_range_ = tensor_range_t ( \"inputs\" , default_minima , default_maxima ) end associate end associate end if if ( present ( output_range )) then inference_engine % output_range_ = output_range else associate ( num_outputs => nodes ( ubound ( nodes , 1 ))) associate ( default_minima => [( 0. , i = 1 , num_outputs )], default_maxima => [( 1. , i = 1 , num_outputs )]) inference_engine % output_range_ = tensor_range_t ( \"outputs\" , default_minima , default_maxima ) end associate end associate end if end block call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) end procedure construct_from_padded_arrays module procedure construct_from_json type ( string_t ), allocatable :: lines (:), metadata (:) type ( tensor_range_t ) input_range , output_range type ( layer_t ) hidden_layers , output_layer type ( neuron_t ) output_neuron real ( rkind ), allocatable :: hidden_weights (:,:,:) integer l lines = file_ % lines () l = 1 #ifndef NAGFOR call assert ( adjustl ( lines ( l )% string ()) == \"{\" , \"construct_from_json: expecting '{' to start outermost object\" , lines ( l )% string ()) #endif l = 2 metadata = [ string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"\" ), string_t ( \"false\" )] if ( adjustl ( lines ( l )% string ()) == '\"metadata\": {' ) then block character ( len = :), allocatable :: justified_line do l = l + 1 justified_line = adjustl ( lines ( l )% string ()) if ( justified_line == \"},\" ) exit metadata ( findloc ( key , trim ( get_key_string ( justified_line )), dim = 1 )) = get_key_value ( justified_line ) end do l = l + 1 end block end if call assert ( adjustl ( lines ( l )% string ()) == '\"tensor_range\": {' , 'from_json: expecting \"tensor_range\": {' , lines ( l )% string ()) #ifndef _CRAYFTN associate ( prototype => tensor_range_t ( \"\" ,[ 0. ],[ 1. ])) #else block type ( tensor_range_t ) prototype prototype = tensor_range_t ( \"\" ,[ 0. ],[ 1. ]) #endif associate ( num_lines => size ( prototype % to_json ())) input_range = tensor_range_t ( lines ( l : l + num_lines - 1 )) l = l + num_lines output_range = tensor_range_t ( lines ( l : l + num_lines - 1 )) l = l + num_lines end associate #ifndef _CRAYFTN end associate #else end block #endif call assert ( adjustl ( lines ( l )% string ()) == '\"hidden_layers\": [' , 'from_json: expecting \"hidden_layers\": [' , lines ( l )% string ()) l = l + 1 block integer , parameter :: lines_per_neuron = 4 , bracket_lines_per_layer = 2 character ( len = :), allocatable :: output_layer_line hidden_layers = layer_t ( lines , start = l ) associate ( output_layer_line_number => l + lines_per_neuron * sum ( hidden_layers % count_neurons ()) & + bracket_lines_per_layer * hidden_layers % count_layers () + 1 ) output_layer_line = lines ( output_layer_line_number )% string () call assert ( adjustl ( output_layer_line ) == '\"output_layer\": [' , 'from_json: expecting \"output_layer\": [' , & lines ( output_layer_line_number )% string ()) output_layer = layer_t ( lines , start = output_layer_line_number ) end associate end block inference_engine = hidden_layers % inference_engine ( metadata , output_layer , input_range , output_range ) call set_activation_strategy ( inference_engine ) call assert_consistency ( inference_engine ) contains pure function get_key_string ( line ) result ( unquoted_key ) character ( len =* ), intent ( in ) :: line character ( len = :), allocatable :: unquoted_key associate ( opening_key_quotes => index ( line , '\"' ), separator => index ( line , ':' )) associate ( closing_key_quotes => opening_key_quotes + index ( line ( opening_key_quotes + 1 :), '\"' )) unquoted_key = trim ( line ( opening_key_quotes + 1 : closing_key_quotes - 1 )) end associate end associate end function function get_key_value ( line ) result ( value_ ) character ( len =* ), intent ( in ) :: line type ( string_t ) value_ #ifdef __INTEL_COMPILER character ( len = :), allocatable :: text_after_colon integer :: opening_value_quotes , closing_value_quotes text_after_colon = line ( index ( line , ':' ) + 1 :) opening_value_quotes = index ( text_after_colon , '\"' ) closing_value_quotes = opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' ) #endif #ifndef __INTEL_COMPILER associate ( text_after_colon => line ( index ( line , ':' ) + 1 :)) associate ( opening_value_quotes => index ( text_after_colon , '\"' )) associate ( closing_value_quotes => opening_value_quotes + index ( text_after_colon ( opening_value_quotes + 1 :), '\"' )) #endif if ( any ([ opening_value_quotes , closing_value_quotes ] == 0 )) then value_ = string_t ( trim ( adjustl (( text_after_colon )))) else value_ = string_t ( text_after_colon ( opening_value_quotes + 1 : closing_value_quotes - 1 )) end if #ifndef __INTEL_COMPILER end associate end associate end associate #endif end function end procedure construct_from_json module procedure assert_conformable_with call assert_consistency ( self ) call assert_consistency ( inference_engine ) associate ( equal_shapes => [ & shape ( self % weights_ ) == shape ( inference_engine % weights_ ), & shape ( self % biases_ ) == shape ( inference_engine % biases_ ), & shape ( self % nodes_ ) == shape ( inference_engine % nodes_ ) & ]) call assert ( all ( equal_shapes ), \"assert_conformable_with: all(equal_shapes)\" , intrinsic_array_t ( equal_shapes )) end associate call assert ( same_type_as ( self % activation_strategy_ , inference_engine % activation_strategy_ ), \"assert_conformable_with: types)\" ) end procedure module procedure subtract call assert_consistency ( self ) call assert_consistency ( rhs ) call self % assert_conformable_with ( rhs ) block integer l allocate ( difference % weights_difference_ , mold = self % weights_ ) allocate ( difference % biases_difference_ , mold = self % biases_ ) allocate ( difference % nodes_difference_ , mold = self % nodes_ ) difference % weights_difference_ = 0. difference % biases_difference_ = 0. difference % nodes_difference_ = 0. l = 0 difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) associate ( n => self % nodes_ ) #ifndef __INTEL_COMPILER do concurrent ( l = 1 : ubound ( n , 1 )) difference % weights_difference_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = self % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - rhs % weights_ ( 1 : n ( l ), 1 : n ( l - 1 ), l ) difference % biases_difference_ ( 1 : n ( l ), l ) = self % biases_ ( 1 : n ( l ), l ) - rhs % biases_ ( 1 : n ( l ), l ) difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) end do #else block integer j , k do l = 1 , ubound ( n , 1 ) do j = 1 , n ( l ) do k = 1 , n ( l - 1 ) difference % weights_difference_ ( j , k , l ) = self % weights_ ( j , k , l ) - rhs % weights_ ( j , k , l ) difference % biases_difference_ ( j , l ) = self % biases_ ( j , l ) - rhs % biases_ ( j , l ) difference % nodes_difference_ ( l ) = self % nodes_ ( l ) - rhs % nodes_ ( l ) end do end do end do end block #endif end associate end block call assert_consistency ( difference ) end procedure module procedure norm norm_of_self = maxval ([ abs ( self % weights_difference_ ), abs ( self % biases_difference_ ), real ( abs ( self % nodes_difference_ ))]) end procedure module procedure num_outputs call assert_consistency ( self ) output_count = self % nodes_ ( ubound ( self % nodes_ , 1 )) end procedure module procedure num_inputs call assert_consistency ( self ) input_count = self % nodes_ ( lbound ( self % nodes_ , 1 )) end procedure module procedure nodes_per_layer call assert_consistency ( self ) node_count = self % nodes_ end procedure module procedure to_json type ( string_t ), allocatable :: lines (:) integer layer , neuron , line integer , parameter :: characters_per_value = 17 character ( len = :), allocatable :: comma_separated_values , csv_format character ( len = 17 ) :: single_value integer , parameter :: & outer_object_braces = 2 , hidden_layer_outer_brackets = 2 , lines_per_neuron = 4 , inner_brackets_per_layer = 2 , & output_layer_brackets = 2 , metadata_outer_braces = 2 , input_range_object = 5 , output_range_object = 5 call assert_consistency ( self ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) associate ( num_hidden_layers => size ( self % nodes_ ) - 2 , & neurons_per_layer => self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 ), & num_outputs => self % num_outputs (), & num_inputs => self % num_inputs () & ) call assert ( all ( neurons_per_layer == self % nodes_ ( lbound ( self % nodes_ , 1 ) + 1 : ubound ( self % nodes_ , 1 ) - 1 )), & \"to_json: uniform hidden layers\" ) associate ( num_lines => & outer_object_braces & + metadata_outer_braces + size ( key ) & + input_range_object + output_range_object & + hidden_layer_outer_brackets + ( num_hidden_layers ) * ( inner_brackets_per_layer + neurons_per_layer * lines_per_neuron ) & + output_layer_brackets + num_outputs * lines_per_neuron & ) allocate ( lines ( num_lines )) line = 1 lines ( line ) = string_t ( '{' ) line = line + 1 lines ( line ) = string_t ( '    \"metadata\": {' ) line = line + 1 lines ( line ) = string_t ( '        \"modelName\": \"' // & self % metadata_ ( findloc ( key , \"modelName\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"modelAuthor\": \"' // & self % metadata_ ( findloc ( key , \"modelAuthor\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"compilationDate\": \"' // & self % metadata_ ( findloc ( key , \"compilationDate\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"activationFunction\": \"' // & self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 ))% string () // '\",' ) line = line + 1 lines ( line ) = string_t ( '        \"usingSkipConnections\": ' // & self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string ()) line = line + 1 lines ( line ) = string_t ( '    },' ) block type ( string_t ), allocatable :: input_range_json (:), output_range_json (:) line = line + 1 input_range_json = self % input_range_ % to_json () associate ( last_line => ubound ( input_range_json , 1 )) call assert ( last_line == input_range_object , \"inference_engine_s(to_json): input_range object line count\" ) input_range_json ( last_line ) = input_range_json ( last_line ) // \",\" lines ( line : line + input_range_object - 1 ) = input_range_json line = line + input_range_object - 1 end associate line = line + 1 output_range_json = self % output_range_ % to_json () associate ( last_line => ubound ( output_range_json , 1 )) call assert ( last_line == output_range_object , \"inference_engine_s(to_json): output_range object line count\" ) output_range_json ( last_line ) = output_range_json ( last_line ) // \",\" lines ( line : line + output_range_object - 1 ) = output_range_json line = line + input_range_object - 1 end associate end block line = line + 1 lines ( line ) = string_t ( '     \"hidden_layers\": [' ) layer = 1 line = line + 1 lines ( line ) = string_t ( '         [' ) do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = num_inputs * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) block integer l associate ( n => self % nodes_ ) l = 1 write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate end block lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do line = line + 1 lines ( line ) = string_t ( trim ( merge ( \"         ] \" , \"         ],\" , any ( num_hidden_layers == [ 1 , line ])))) do layer = 1 , num_hidden_layers - 1 line = line + 1 lines ( line ) = string_t ( '         [' ) block real ( rkind ), allocatable :: hidden_layer_weights (:,:) integer j , l associate ( n => self % nodes_ , l => layer + 1 ) allocate ( hidden_layer_weights ( n ( l ), n ( l - 1 ))) do concurrent ( j = 1 : n ( l )) hidden_layer_weights ( j , 1 : n ( l - 1 )) = self % weights_ ( j , 1 : n ( l - 1 ), l ) end do hidden_layer_weights = transpose ( hidden_layer_weights ) end associate do neuron = 1 , neurons_per_layer line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) write ( comma_separated_values , fmt = csv_format ) hidden_layer_weights (:, neuron ) lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , layer + 1 ) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == neurons_per_layer ))) end do end block line = line + 1 lines ( line ) = string_t ( \"         ]\" // trim ( merge ( ' ' , ',' , layer == num_hidden_layers - 1 ))) end do line = line + 1 lines ( line ) = string_t ( \"     ],\" ) line = line + 1 lines ( line ) = string_t ( '     \"output_layer\": [' ) do neuron = 1 , num_outputs line = line + 1 lines ( line ) = string_t ( '             {' ) line = line + 1 if ( allocated ( comma_separated_values )) deallocate ( comma_separated_values ) allocate ( character ( len = neurons_per_layer * ( characters_per_value + 1 ) - 1 ) :: comma_separated_values ) associate ( n => self % nodes_ , l => ubound ( self % nodes_ , 1 )) write ( comma_separated_values , fmt = csv_format ) self % weights_ ( neuron , 1 : n ( l - 1 ), l ) end associate lines ( line ) = string_t ( '                \"weights\": [' // trim ( comma_separated_values ) // '],' ) line = line + 1 write ( single_value , fmt = csv_format ) self % biases_ ( neuron , ubound ( self % biases_ , 2 )) lines ( line ) = string_t ( '                 \"bias\": ' // trim ( single_value )) line = line + 1 lines ( line ) = string_t ( \"             }\" // trim ( merge ( ' ' , ',' , neuron == num_outputs ))) end do line = line + 1 lines ( line ) = string_t ( '     ]' ) line = line + 1 lines ( line ) = string_t ( '}' ) call assert ( line == num_lines , \"inference_engine_t%to_json: all lines defined\" , intrinsic_array_t ([ num_lines , line ])) end associate end associate json_file = file_t ( lines ) end procedure to_json module procedure skip use_skip_connections = self % metadata_ ( findloc ( key , \"usingSkipConnections\" , dim = 1 ))% string () == \"true\" end procedure module procedure activation_function_name activation_name = self % metadata_ ( findloc ( key , \"activationFunction\" , dim = 1 )) end procedure end submodule inference_engine_s","tags":"","loc":"sourcefile/inference_engine_s.f90.html"},{"title":"step_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_m.f90~~EfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~step_m.f90~~AfferentGraph sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module step_m use activation_strategy_m , only : activation_strategy_t use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: step_t type , extends ( activation_strategy_t ) :: step_t contains procedure , nopass :: activation procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( step_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module step_m","tags":"","loc":"sourcefile/step_m.f90.html"},{"title":"tensor_range_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_range_m.f90~~EfferentGraph sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tensor_range_m.f90~~AfferentGraph sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~tensor_range_s.f90 tensor_range_s.f90 sourcefile~tensor_range_s.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_range_m use tensor_m , only : tensor_t use julienne_m , only : string_t implicit none private public :: tensor_range_t type tensor_range_t private character ( len = :), allocatable :: layer_ real , allocatable , dimension (:) :: minima_ , maxima_ contains procedure map_to_training_range procedure map_from_training_range procedure to_json procedure in_range generic :: operator ( == ) => equals procedure , private :: equals end type interface tensor_range_t pure module function from_components ( layer , minima , maxima ) result ( tensor_range ) implicit none character ( len =* ), intent ( in ) :: layer real , dimension (:), intent ( in ) :: minima , maxima type ( tensor_range_t ) tensor_range end function module function from_json ( lines ) result ( tensor_range ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( tensor_range_t ) tensor_range end function end interface interface elemental module function map_to_training_range ( self , tensor ) result ( normalized_tensor ) implicit none class ( tensor_range_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function map_from_training_range ( self , tensor ) result ( unnormalized_tensor ) implicit none class ( tensor_range_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) unnormalized_tensor end function pure module function to_json ( self ) result ( lines ) implicit none class ( tensor_range_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( tensor_range_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function in_range ( self , tensor ) result ( is_in_range ) implicit none class ( tensor_range_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor logical is_in_range end function end interface end module tensor_range_m","tags":"","loc":"sourcefile/tensor_range_m.f90.html"},{"title":"layer_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_m.f90~~EfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~layer_m.f90~~AfferentGraph sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module layer_m use neuron_m , only : neuron_t use julienne_string_m , only : string_t use kind_parameters_m , only : rkind use inference_engine_m_ , only : inference_engine_t use tensor_range_m , only : tensor_range_t implicit none private public :: layer_t type layer_t !! linked list of layers, each comprised of a linked list of neurons private type ( neuron_t ) neuron !! linked list of this layer's neurons type ( layer_t ), allocatable :: next !! next layer contains procedure :: inference_engine procedure :: count_layers procedure :: count_neurons procedure :: count_inputs procedure :: neurons_per_layer procedure :: next_allocated procedure :: next_pointer end type interface layer_t recursive module function construct_layer ( layer_lines , start ) result ( layer ) !! construct a linked list of layer_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: layer_lines (:) integer , intent ( in ) :: start type ( layer_t ), target :: layer end function end interface interface module function inference_engine ( hidden_layers , metadata , output_layer , input_range , output_range ) result ( inference_engine_ ) implicit none class ( layer_t ), intent ( in ), target :: hidden_layers type ( layer_t ), intent ( in ), target :: output_layer type ( string_t ), intent ( in ) :: metadata (:) type ( tensor_range_t ), intent ( in ) :: input_range , output_range type ( inference_engine_t ) inference_engine_ end function module function count_layers ( layer ) result ( num_layers ) implicit none class ( layer_t ), intent ( in ), target :: layer integer num_layers end function module function count_neurons ( layer ) result ( neurons_per_layer_result ) implicit none class ( layer_t ), intent ( in ), target :: layer integer , allocatable :: neurons_per_layer_result (:) end function module function count_inputs ( layer ) result ( num_inputs ) implicit none class ( layer_t ), intent ( in ) :: layer integer num_inputs end function module function neurons_per_layer ( self ) result ( num_neurons ) implicit none class ( layer_t ), intent ( in ), target :: self integer num_neurons end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( layer_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( layer_t ), intent ( in ), target :: self type ( layer_t ), pointer :: next_ptr end function end interface end module","tags":"","loc":"sourcefile/layer_m.f90.html"},{"title":"learn-exponentiation.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-exponentiation.f90~~EfferentGraph sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module exponentiation_m !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) ** 2 , x ( 2 ) ** 3 , x ( 3 ) ** 4 , x ( 4 ) ** 4 , x ( 5 ) ** 3 , x ( 6 ) ** 2 ]) end associate end function end module program learn_exponentiation !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use exponentiation_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-polynomials --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] ! nodes per layer (first layer = input, last layer = output) integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-exponentiation.f90.html"},{"title":"trainable_engine_s.F90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_s.f90~~EfferentGraph sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( trainable_engine_m ) trainable_engine_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t use tensor_m , only : tensor_t #ifdef _CRAYFTN use input_output_pair_m , only : input_output_pair_t #endif implicit none integer , parameter :: input_layer = 0 contains module procedure num_inputs n_in = self % n ( input_layer ) end procedure module procedure num_layers n_layers = size ( self % n , 1 ) end procedure module procedure num_outputs n_out = self % n ( ubound ( self % n , 1 )) end procedure module procedure construct_from_inference_engine #ifndef _CRAYFTN associate ( exchange => inference_engine % to_exchange ()) #else use inference_engine_m_ , only : exchange_t type ( exchange_t ) exchange exchange = inference_engine % to_exchange () #endif trainable_engine % input_range_ = exchange % input_range_ trainable_engine % output_range_ = exchange % output_range_ trainable_engine % metadata_ = exchange % metadata_ trainable_engine % w = exchange % weights_ trainable_engine % b = exchange % biases_ trainable_engine % n = exchange % nodes_ select type ( activation => exchange % activation_strategy_ ) class is ( differentiable_activation_strategy_t ) trainable_engine % differentiable_activation_strategy_ = activation class default error stop & \"trainable_engine_s(from_inference_engine): activation strategy must be a differentiable_activation_stragegy_t\" end select #ifndef _CRAYFTN end associate #endif end procedure module procedure assert_consistent associate ( & fully_allocated => [ allocated ( self % w ), allocated ( self % b ), allocated ( self % n ), allocated ( self % differentiable_activation_strategy_ )] & ) call assert ( all ( fully_allocated ), \"trainable_engine_s(assert_consistent): fully_allocated\" , intrinsic_array_t ( fully_allocated )) end associate associate ( max_width => maxval ( self % n ), component_dims => [ size ( self % b , 1 ), size ( self % w , 1 ), size ( self % w , 2 )]) call assert ( all ( component_dims == max_width ), \"trainable_engine_s(assert_consistent): conformable arrays\" , & intrinsic_array_t ([ max_width , component_dims ])) end associate call assert ( lbound ( self % n , 1 ) == input_layer , \"trainable_engine_s(assert_consistent): n base subsscript\" , lbound ( self % n , 1 )) end procedure module procedure infer real ( rkind ), allocatable :: a (:,:) integer l call self % assert_consistent associate ( w => self % w , b => self % b , n => self % n , output_layer => ubound ( self % n , 1 )) allocate ( a ( maxval ( n ), input_layer : output_layer )) ! Activations #ifndef _CRAYFTN associate ( normalized_inputs => self % input_range_ % map_to_training_range ( inputs )) #else block type ( tensor_t ) normalized_inputs normalized_inputs = self % input_range_ % map_to_training_range ( inputs ) #endif a ( 1 : n ( input_layer ), input_layer ) = normalized_inputs % values () #ifndef _CRAYFTN end associate #else end block #endif feed_forward : & do l = 1 , output_layer a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( & matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) & ) end do feed_forward associate ( normalized_outputs => tensor_t ( a ( 1 : n ( output_layer ), output_layer ))) outputs = self % output_range_ % map_from_training_range ( normalized_outputs ) end associate end associate end procedure module procedure train integer l , batch , mini_batch_size , pair real ( rkind ), allocatable :: & z (:,:), a (:,:), delta (:,:), dcdw (:,:,:), dcdb (:,:), vdw (:,:,:), sdw (:,:,:), vdb (:,:), sdb (:,:), vdwc (:,:,:), sdwc (:,:,:), & vdbc (:,:), sdbc (:,:) type ( tensor_t ), allocatable :: inputs (:), expected_outputs (:) real ( rkind ) eta , alpha eta = learning_rate alpha = learning_rate call self % assert_consistent associate ( output_layer => ubound ( self % n , 1 )) allocate ( a ( maxval ( self % n ), input_layer : output_layer )) ! Activations allocate ( dcdw , mold = self % w ) ! Gradient of cost function with respect to weights allocate ( vdw , mold = self % w ) allocate ( sdw , mold = self % w ) allocate ( vdwc , mold = self % w ) allocate ( sdwc , mold = self % w ) allocate ( z , mold = self % b ) ! z-values: Sum z_j&#94;l = w_jk&#94;{l} a_k&#94;{l-1} + b_j&#94;l allocate ( delta , mold = self % b ) allocate ( dcdb , mold = self % b ) ! Gradient of cost function with respect with biases allocate ( vdb , mold = self % b ) allocate ( sdb , mold = self % b ) allocate ( vdbc , mold = self % b ) allocate ( sdbc , mold = self % b ) vdw = 0.d0 sdw = 1.d0 vdb = 0.d0 sdb = 1.d0 associate ( w => self % w , b => self % b , n => self % n , num_mini_batches => size ( mini_batches_arr )) if ( present ( cost )) allocate ( cost ( num_mini_batches )) iterate_across_batches : & do batch = 1 , num_mini_batches if ( present ( cost )) cost ( batch ) = 0. dcdw = 0. ; dcdb = 0. #ifndef _CRAYFTN associate ( input_output_pairs => mini_batches_arr ( batch )% input_output_pairs ()) #else block type ( input_output_pair_t ), allocatable :: input_output_pairs (:) input_output_pairs = mini_batches_arr ( batch )% input_output_pairs () #endif inputs = input_output_pairs % inputs () expected_outputs = input_output_pairs % expected_outputs () mini_batch_size = size ( input_output_pairs ) #ifndef _CRAYFTN end associate #else end block #endif iterate_through_batch : & do pair = 1 , mini_batch_size a ( 1 : self % num_inputs (), input_layer ) = inputs ( pair )% values () feed_forward : & do l = 1 , output_layer z ( 1 : n ( l ), l ) = matmul ( w ( 1 : n ( l ), 1 : n ( l - 1 ), l ), a ( 1 : n ( l - 1 ), l - 1 )) + b ( 1 : n ( l ), l ) a ( 1 : n ( l ), l ) = self % differentiable_activation_strategy_ % activation ( z ( 1 : n ( l ), l )) end do feed_forward associate ( y => expected_outputs ( pair )% values ()) if ( present ( cost )) & cost ( batch ) = cost ( batch ) + sum (( y ( 1 : n ( output_layer )) - a ( 1 : n ( output_layer ), output_layer )) ** 2 ) / ( 2.e0 * mini_batch_size ) delta ( 1 : n ( output_layer ), output_layer ) = & ( a ( 1 : n ( output_layer ), output_layer ) - y ( 1 : n ( output_layer ))) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( output_layer ), output_layer )) end associate associate ( n_hidden => self % num_layers () - 2 ) back_propagate_error : & do l = n_hidden , 1 , - 1 delta ( 1 : n ( l ), l ) = matmul ( transpose ( w ( 1 : n ( l + 1 ), 1 : n ( l ), l + 1 )), delta ( 1 : n ( l + 1 ), l + 1 )) & * self % differentiable_activation_strategy_ % activation_derivative ( z ( 1 : n ( l ), l )) end do back_propagate_error end associate block integer j sum_gradients : & do l = 1 , output_layer dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) + delta ( 1 : n ( l ), l ) do concurrent ( j = 1 : n ( l )) dcdw ( j , 1 : n ( l - 1 ), l ) = dcdw ( j , 1 : n ( l - 1 ), l ) + a ( 1 : n ( l - 1 ), l - 1 ) * delta ( j , l ) end do end do sum_gradients end block end do iterate_through_batch if ( adam ) then block ! Adam parameters real , parameter :: beta ( * ) = [. 9_rkind , . 999_rkind ] real , parameter :: obeta ( * ) = [ 1._rkind - beta ( 1 ), 1._rkind - beta ( 2 )] real , parameter :: epsilon = real ( 1.D-08 , rkind ) adam_adjust_weights_and_biases : & do concurrent ( l = 1 : output_layer ) dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( mini_batch_size ) vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 1 ) * vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 1 ) * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = beta ( 2 ) * sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) + obeta ( 2 ) * ( dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ** 2 ) vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = vdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1._rkind - beta ( 1 ) ** num_mini_batches ) sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = sdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( 1._rkind - beta ( 2 ) ** num_mini_batches ) w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) & - alpha * vdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / ( sqrt ( sdwc ( 1 : n ( l ), 1 : n ( l - 1 ), l )) + epsilon ) ! Adjust weights dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size vdb ( 1 : n ( l ), l ) = beta ( 1 ) * vdb ( 1 : n ( l ), l ) + obeta ( 1 ) * dcdb ( 1 : n ( l ), l ) sdb ( 1 : n ( l ), l ) = beta ( 2 ) * sdb ( 1 : n ( l ), l ) + obeta ( 2 ) * ( dcdb ( 1 : n ( l ), l ) ** 2 ) vdbc ( 1 : n ( l ), l ) = vdb ( 1 : n ( l ), l ) / ( 1._rkind - beta ( 1 ) ** num_mini_batches ) sdbc ( 1 : n ( l ), l ) = sdb ( 1 : n ( l ), l ) / ( 1._rkind - beta ( 2 ) ** num_mini_batches ) b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - alpha * vdbc ( 1 : n ( l ), l ) / ( sqrt ( sdbc ( 1 : n ( l ), l )) + epsilon ) ! Adjust weights end do adam_adjust_weights_and_biases end block else adjust_weights_and_biases : & do concurrent ( l = 1 : output_layer ) dcdb ( 1 : n ( l ), l ) = dcdb ( 1 : n ( l ), l ) / mini_batch_size b ( 1 : n ( l ), l ) = b ( 1 : n ( l ), l ) - eta * dcdb ( 1 : n ( l ), l ) ! Adjust biases dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) / mini_batch_size w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) = w ( 1 : n ( l ), 1 : n ( l - 1 ), l ) - eta * dcdw ( 1 : n ( l ), 1 : n ( l - 1 ), l ) ! Adjust weights end do adjust_weights_and_biases end if end do iterate_across_batches end associate end associate end procedure #ifdef __INTEL_COMPILER module procedure construct_trainable_engine_from_padded_arrays #else module procedure construct_from_padded_arrays #endif trainable_engine % metadata_ = metadata trainable_engine % n = nodes trainable_engine % w = weights trainable_engine % b = biases trainable_engine % differentiable_activation_strategy_ = differentiable_activation_strategy block integer i if ( present ( input_range )) then trainable_engine % input_range_ = input_range else associate ( num_inputs => nodes ( lbound ( nodes , 1 ))) trainable_engine % input_range_ = tensor_range_t ( \"inputs\" , minima = [( 0. , i = 1 , num_inputs )], maxima = [( 1. , i = 1 , num_inputs )]) end associate end if if ( present ( output_range )) then trainable_engine % output_range_ = output_range else associate ( num_outputs => nodes ( ubound ( nodes , 1 ))) trainable_engine % output_range_ = tensor_range_t ( \"outputs\" , minima = [( 0. , i = 1 , num_outputs )], maxima = [( 1. , i = 1 , num_outputs )]) end associate end if end block call trainable_engine % assert_consistent end procedure module procedure to_inference_engine ! assignment-stmt disallows the procedure from being pure because it might ! deallocate polymorphic allocatable subcomponent `activation_strategy_` ! TODO: consider how this affects design inference_engine = inference_engine_t ( self % metadata_ , self % w , self % b , self % n , self % input_range_ , self % output_range_ ) end procedure module procedure perturbed_identity_network integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n => training_configuration % nodes_per_layer ()) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( & w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , & b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 , & activation => training_configuration % differentiable_activation_strategy () & ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = activation , metadata = metadata , & input_range = input_range , output_range = output_range & ) end associate end associate end associate contains pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function end procedure module procedure map_to_input_training_range normalized_tensor = self % input_range_ % map_to_training_range ( tensor ) end procedure module procedure map_from_input_training_range unnormalized_tensor = self % input_range_ % map_from_training_range ( tensor ) end procedure module procedure map_to_output_training_range normalized_tensor = self % output_range_ % map_to_training_range ( tensor ) end procedure module procedure map_from_output_training_range unnormalized_tensor = self % output_range_ % map_from_training_range ( tensor ) end procedure end submodule trainable_engine_s","tags":"","loc":"sourcefile/trainable_engine_s.f90.html"},{"title":"network_configuration_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~network_configuration_m.f90~~AfferentGraph sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~network_configuration_s.f90 network_configuration_s.F90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module network_configuration_m use julienne_string_m , only : string_t implicit none private public :: network_configuration_t type network_configuration_t private logical :: skip_connections_ = . false . integer , allocatable :: nodes_per_layer_ (:) character ( len = :), allocatable :: activation_name_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: activation_name procedure :: nodes_per_layer procedure :: skip_connections end type interface network_configuration_t pure module function from_json ( lines ) result ( network_configuration ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( network_configuration_t ) network_configuration end function pure module function from_components ( skip_connections , nodes_per_layer , activation_name ) result ( network_configuration ) implicit none logical , intent ( in ) :: skip_connections integer , intent ( in ) :: nodes_per_layer (:) character ( len =* ), intent ( in ) :: activation_name type ( network_configuration_t ) network_configuration end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( network_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function activation_name ( self ) result ( string ) implicit none class ( network_configuration_t ), intent ( in ) :: self type ( string_t ) string end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( network_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( network_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/network_configuration_m.f90.html"},{"title":"hyperparameters_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_m.f90~~EfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~hyperparameters_m.f90~~AfferentGraph sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module hyperparameters_m use julienne_string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: hyperparameters_t type hyperparameters_t private integer :: mini_batches_ = 10 real :: learning_rate_ = 1.5 character ( len = :), allocatable :: optimizer_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate end type interface hyperparameters_t pure module function from_json ( lines ) result ( hyperparameters ) implicit none type ( string_t ), intent ( in ) :: lines (:) type ( hyperparameters_t ) hyperparameters end function pure module function from_components ( mini_batches , learning_rate , optimizer ) result ( hyperparameters ) implicit none integer , intent ( in ) :: mini_batches real , intent ( in ) :: learning_rate character ( len =* ), intent ( in ) :: optimizer type ( hyperparameters_t ) hyperparameters end function end interface interface pure module function to_json ( self ) result ( lines ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ), allocatable :: lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_equals_rhs ) implicit none class ( hyperparameters_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( hyperparameters_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( hyperparameters_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( hyperparameters_t ), intent ( in ) :: self real ( rkind ) rate end function end interface end module","tags":"","loc":"sourcefile/hyperparameters_m.f90.html"},{"title":"print-training-configuration.F90 – Inference-Engine","text":"This file depends on sourcefile~~print-training-configuration.f90~~EfferentGraph sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program print_training_configuration !! Demonstrate how to construct and print a training_configuration_t object use inference_engine_m , only : training_configuration_t , hyperparameters_t , network_configuration_t use julienne_m , only : file_t implicit none #ifdef _CRAYFTN type ( training_configuration_t ) :: training_configuration type ( file_t ) :: json_file training_configuration = training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" )) json_file = file_t ( training_configuration % to_json ()) call json_file % write_lines () #else associate ( training_configuration => training_configuration_t ( & hyperparameters_t ( mini_batches = 10 , learning_rate = 1.5 , optimizer = \"adam\" ), & network_configuration_t ( skip_connections = . false ., nodes_per_layer = [ 2 , 72 , 2 ], activation_name = \"sigmoid\" ) & )) associate ( json_file => file_t ( training_configuration % to_json ())) call json_file % write_lines () end associate end associate #endif end program","tags":"","loc":"sourcefile/print-training-configuration.f90.html"},{"title":"inference_engine_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~inference_engine_m.f90~~EfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~inference_engine_m.f90~~AfferentGraph sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module inference_engine_m !! Specify the user-facing modules, derived types, and type parameters use activation_strategy_m , only : activation_strategy_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use hyperparameters_m , only : hyperparameters_t use input_output_pair_m , only : input_output_pair_t , shuffle use inference_engine_m_ , only : inference_engine_t , difference_t , infer use kind_parameters_m , only : rkind use mini_batch_m , only : mini_batch_t use network_configuration_m , only : network_configuration_t use gelu_m , only : gelu_t use relu_m , only : relu_t use sigmoid_m , only : sigmoid_t use step_m , only : step_t use swish_m , only : swish_t use tensor_m , only : tensor_t use tensor_range_m , only : tensor_range_t use trainable_engine_m , only : trainable_engine_t use training_configuration_m , only : training_configuration_t use ubounds_m , only : ubounds_t implicit none end module","tags":"","loc":"sourcefile/inference_engine_m.f90.html"},{"title":"gelu_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~gelu_m.f90~~EfferentGraph sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~gelu_m.f90~~AfferentGraph sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~gelu_s.f90 gelu_s.f90 sourcefile~gelu_s.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~gelu_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module gelu_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: gelu_t type , extends ( differentiable_activation_strategy_t ) :: gelu_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( gelu_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module gelu_m","tags":"","loc":"sourcefile/gelu_m.f90.html"},{"title":"gelu_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~gelu_s.f90~~EfferentGraph sourcefile~gelu_s.f90 gelu_s.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~gelu_s.f90->sourcefile~gelu_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~gelu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( gelu_m ) gelu_s use kind_parameters_m , only : rkind implicit none real ( rkind ), parameter :: pi = 3.141592653589793_rkind real ( rkind ), parameter :: half = 0.5_rkind , one = 1._rkind , two = 2._rkind real ( rkind ), parameter :: sqrt_2_pi = sqrt ( two * pi ), sqrt_2 = sqrt ( two ) contains module procedure activation y = half * x * ( one + erf ( x / sqrt_2 )) end procedure module procedure activation_derivative y = half * ( one + erf ( x / sqrt_2 )) + x * exp ( - x ** 2 / two ) / sqrt_2_pi end procedure module procedure function_name string = string_t ( \"gelu\" ) end procedure end submodule gelu_s","tags":"","loc":"sourcefile/gelu_s.f90.html"},{"title":"neuron_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_m.f90~~EfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~neuron_m.f90~~AfferentGraph sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module neuron_m use julienne_string_m , only : string_t use kind_parameters_m , only : rkind implicit none private public :: neuron_t type neuron_t !! linked list of neurons private real ( rkind ), allocatable :: weights_ (:) real ( rkind ) bias_ type ( neuron_t ), allocatable :: next contains procedure :: weights procedure :: bias procedure :: next_allocated procedure :: next_pointer procedure :: num_inputs end type interface neuron_t pure recursive module function construct ( neuron_lines , start ) result ( neuron ) !! construct linked list of neuron_t objects from an array of JSON-formatted text lines implicit none type ( string_t ), intent ( in ) :: neuron_lines (:) integer , intent ( in ) :: start type ( neuron_t ) neuron end function end interface interface module function weights ( self ) result ( my_weights ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ), allocatable :: my_weights (:) end function module function bias ( self ) result ( my_bias ) implicit none class ( neuron_t ), intent ( in ) :: self real ( rkind ) my_bias end function module function next_allocated ( self ) result ( next_is_allocated ) implicit none class ( neuron_t ), intent ( in ) :: self logical next_is_allocated end function module function next_pointer ( self ) result ( next_ptr ) implicit none class ( neuron_t ), intent ( in ), target :: self type ( neuron_t ), pointer :: next_ptr end function pure module function num_inputs ( self ) result ( size_weights ) implicit none class ( neuron_t ), intent ( in ) :: self integer size_weights end function end interface end module","tags":"","loc":"sourcefile/neuron_m.f90.html"},{"title":"relu_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_s.f90~~EfferentGraph sourcefile~relu_s.f90 relu_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( relu_m ) relu_s use kind_parameters_m , only : rkind implicit none real ( rkind ), parameter :: zero = 0._rkind , one = 1._rkind contains module procedure activation y = max ( zero , x ) end procedure module procedure activation_derivative y = merge ( one , zero , x > zero ) end procedure module procedure function_name string = string_t ( \"relu\" ) end procedure end submodule relu_s","tags":"","loc":"sourcefile/relu_s.f90.html"},{"title":"mini_batch_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_m.f90~~EfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~mini_batch_m.f90~~AfferentGraph sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module mini_batch_m use input_output_pair_m , only : input_output_pair_t use kind_parameters_m , only : rkind implicit none private public :: mini_batch_t type mini_batch_t private type ( input_output_pair_t ), allocatable :: input_output_pairs_ (:) contains procedure :: input_output_pairs end type interface mini_batch_t pure module function construct ( input_output_pairs ) result ( mini_batch ) implicit none type ( input_output_pair_t ), intent ( in ) :: input_output_pairs (:) type ( mini_batch_t ) mini_batch end function end interface interface pure module function input_output_pairs ( self ) result ( my_input_output_pairs ) implicit none class ( mini_batch_t ), intent ( in ) :: self type ( input_output_pair_t ), allocatable :: my_input_output_pairs (:) end function end interface end module mini_batch_m","tags":"","loc":"sourcefile/mini_batch_m.f90.html"},{"title":"sigmoid_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~sigmoid_s.f90~~EfferentGraph sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( sigmoid_m ) sigmoid_s implicit none contains module procedure activation y = 1. / ( 1. + exp ( - x )) end procedure module procedure activation_derivative y = exp ( - x ) / ( 1. + exp ( - x )) ** 2 end procedure module procedure function_name string = string_t ( \"sigmoid\" ) end procedure end submodule sigmoid_s","tags":"","loc":"sourcefile/sigmoid_s.f90.html"},{"title":"trainable_engine_m.F90 – Inference-Engine","text":"This file depends on sourcefile~~trainable_engine_m.f90~~EfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~trainable_engine_m.f90~~AfferentGraph sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module trainable_engine_m !! Define an abstraction that supports training a neural network use julienne_string_m , only : string_t use inference_engine_m_ , only : inference_engine_t use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use tensor_m , only : tensor_t use tensor_range_m , only : tensor_range_t use mini_batch_m , only : mini_batch_t use training_configuration_m , only : training_configuration_t implicit none private public :: trainable_engine_t type trainable_engine_t !! Encapsulate the information needed to perform training private type ( tensor_range_t ) input_range_ , output_range_ type ( string_t ), allocatable :: metadata_ (:) real ( rkind ), allocatable :: w (:,:,:) ! weights real ( rkind ), allocatable :: b (:,:) ! biases integer , allocatable :: n (:) ! nodes per layer class ( differentiable_activation_strategy_t ), allocatable :: differentiable_activation_strategy_ contains procedure :: assert_consistent procedure :: train procedure :: infer procedure :: num_layers procedure :: num_inputs procedure :: num_outputs procedure :: to_inference_engine procedure :: map_to_input_training_range procedure :: map_from_input_training_range procedure :: map_to_output_training_range procedure :: map_from_output_training_range end type integer , parameter :: input_layer = 0 interface trainable_engine_t #ifdef __INTEL_COMPILER impure module function construct_trainable_engine_from_padded_arrays ( & nodes , weights , biases , differentiable_activation_strategy , metadata , input_range , output_range & ) & #else impure module function construct_from_padded_arrays ( & nodes , weights , biases , differentiable_activation_strategy , metadata , input_range , output_range & ) & #endif result ( trainable_engine ) implicit none integer , intent ( in ) :: nodes ( input_layer :) real ( rkind ), intent ( in ) :: weights (:,:,:), biases (:,:) class ( differentiable_activation_strategy_t ), intent ( in ) :: differentiable_activation_strategy type ( string_t ), intent ( in ) :: metadata (:) type ( tensor_range_t ), intent ( in ), optional :: input_range , output_range type ( trainable_engine_t ) trainable_engine end function impure module function construct_from_inference_engine ( inference_engine ) result ( trainable_engine ) implicit none type ( inference_engine_t ), intent ( in ) :: inference_engine type ( trainable_engine_t ) trainable_engine end function module function perturbed_identity_network ( training_configuration , perturbation_magnitude , metadata , input_range , output_range )& result ( trainable_engine ) implicit none type ( training_configuration_t ), intent ( in ) :: training_configuration type ( string_t ), intent ( in ) :: metadata (:) real ( rkind ), intent ( in ) :: perturbation_magnitude type ( tensor_range_t ) input_range , output_range type ( trainable_engine_t ) trainable_engine end function end interface interface pure module subroutine assert_consistent ( self ) implicit none class ( trainable_engine_t ), intent ( in ) :: self end subroutine pure module subroutine train ( self , mini_batches_arr , cost , adam , learning_rate ) implicit none class ( trainable_engine_t ), intent ( inout ) :: self type ( mini_batch_t ), intent ( in ) :: mini_batches_arr (:) real ( rkind ), intent ( out ), allocatable , optional :: cost (:) logical , intent ( in ) :: adam real ( rkind ), intent ( in ) :: learning_rate end subroutine elemental module function infer ( self , inputs ) result ( outputs ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: inputs type ( tensor_t ) outputs end function elemental module function num_inputs ( self ) result ( n_in ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_in end function elemental module function num_outputs ( self ) result ( n_out ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_out end function elemental module function num_layers ( self ) result ( n_layers ) implicit none class ( trainable_engine_t ), intent ( in ) :: self integer n_layers end function module function to_inference_engine ( self ) result ( inference_engine ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( inference_engine_t ) :: inference_engine end function elemental module function map_to_input_training_range ( self , tensor ) result ( normalized_tensor ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function map_from_input_training_range ( self , tensor ) result ( unnormalized_tensor ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) unnormalized_tensor end function elemental module function map_to_output_training_range ( self , tensor ) result ( normalized_tensor ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) normalized_tensor end function elemental module function map_from_output_training_range ( self , tensor ) result ( unnormalized_tensor ) implicit none class ( trainable_engine_t ), intent ( in ) :: self type ( tensor_t ), intent ( in ) :: tensor type ( tensor_t ) unnormalized_tensor end function end interface end module trainable_engine_m","tags":"","loc":"sourcefile/trainable_engine_m.f90.html"},{"title":"layer_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~layer_s.f90~~EfferentGraph sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( layer_m ) layer_s use assert_m , only : assert use intrinsic_array_m , only : intrinsic_array_t implicit none contains module procedure construct_layer type ( neuron_t ), pointer :: neuron integer num_inputs , neurons_in_layer character ( len = :), allocatable :: line logical hidden_layers , output_layer line = adjustl ( layer_lines ( start )% string ()) hidden_layers = line == '[' output_layer = line == '\"output_layer\": [' call assert ( hidden_layers . or . output_layer , \"layer_t construct_layer: layer start\" , line ) layer % neuron = neuron_t ( layer_lines , start + 1 ) num_inputs = size ( layer % neuron % weights ()) neuron => layer % neuron neurons_in_layer = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () call assert ( size ( neuron % weights ()) == num_inputs , \"layer_t construct_layer: constant number of inputs\" ) neurons_in_layer = neurons_in_layer + 1 end do line = trim ( adjustl ( layer_lines ( start + 4 * neurons_in_layer + 1 )% string ())) call assert ( line ( 1 : 1 ) == ']' , \"read_layer_list: hidden layer end\" ) if ( line ( len ( line ): len ( line )) == \",\" ) layer % next = construct_layer ( layer_lines , start + 4 * neurons_in_layer + 2 ) end procedure module procedure inference_engine associate ( & num_inputs => hidden_layers % count_inputs (), & num_outputs => output_layer % count_neurons (), & neurons_per_hidden_layer => hidden_layers % count_neurons (), & num_hidden_layers => hidden_layers % count_layers (), & num_output_layers => output_layer % count_layers () & ) call assert ( num_output_layers == 1 , \"inference_engine_s(construct_from_json): 1 output layer\" , num_output_layers ) associate ( nodes => [ num_inputs , neurons_per_hidden_layer , num_outputs ]) associate ( n_max => maxval ( nodes )) block real ( rkind ), allocatable :: weights (:,:,:), biases (:,:) type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer j , l allocate ( weights ( n_max , n_max , num_hidden_layers + num_output_layers )) allocate ( biases ( n_max , num_hidden_layers + num_output_layers )) layer_ptr => hidden_layers l = 0 loop_over_hidden_Layers : & do l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_hidden_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_hidden_neurons if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next_pointer () end do loop_over_hidden_Layers layer_ptr => output_layer l = l + 1 neuron_ptr => layer_ptr % neuron j = 0 loop_over_output_neurons : & do j = j + 1 associate ( w => neuron_ptr % weights ()) weights ( j , 1 : size ( w , 1 ), l ) = w end associate biases ( j , l ) = neuron_ptr % bias () if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () end do loop_over_output_neurons inference_engine_ = inference_engine_t ( metadata , weights , biases , nodes , input_range , output_range ) end block end associate end associate end associate end procedure module procedure count_layers type ( layer_t ), pointer :: layer_ptr layer_ptr => layer num_layers = 1 do if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next num_layers = num_layers + 1 end do end procedure module procedure count_neurons type ( layer_t ), pointer :: layer_ptr type ( neuron_t ), pointer :: neuron_ptr integer num_neurons layer_ptr => layer allocate ( neurons_per_layer_result ( 0 )) do num_neurons = 1 neuron_ptr => layer_ptr % neuron do if (. not . neuron_ptr % next_allocated ()) exit neuron_ptr => neuron_ptr % next_pointer () num_neurons = num_neurons + 1 end do neurons_per_layer_result = [ neurons_per_layer_result , num_neurons ] if (. not . allocated ( layer_ptr % next )) exit layer_ptr => layer_ptr % next end do end procedure module procedure count_inputs num_inputs = layer % neuron % num_inputs () ! assume fully connected input layer end procedure module procedure neurons_per_layer type ( neuron_t ), pointer :: neuron neuron => self % neuron num_neurons = 1 do if (. not . neuron % next_allocated ()) exit neuron => neuron % next_pointer () num_neurons = num_neurons + 1 end do end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure end submodule layer_s","tags":"","loc":"sourcefile/layer_s.f90.html"},{"title":"neuron_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~neuron_s.f90~~EfferentGraph sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( neuron_m ) neuron_s use assert_m , only : assert implicit none contains module procedure construct character ( len = :), allocatable :: line integer i call assert ( adjustl ( neuron_lines ( start )% string ()) == '{' , \"neuron_s(construct): neuron object start\" , neuron_lines ( start )% string ()) line = neuron_lines ( start + 1 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"weights\"' , \"neuron_s(construct): neuron weights\" , line ) associate ( opening_bracket => colon + index ( line ( colon + 1 :), \"[\" )) associate ( closing_bracket => opening_bracket + index ( line ( opening_bracket + 1 :), \"]\" )) associate ( commas => count ( \",\" == [( line ( i : i ), i = opening_bracket + 1 , closing_bracket - 1 )])) associate ( num_inputs => commas + 1 ) allocate ( neuron % weights_ ( num_inputs )) read ( line ( opening_bracket + 1 : closing_bracket - 1 ), fmt =* ) neuron % weights_ end associate end associate end associate end associate end associate line = neuron_lines ( start + 2 )% string () associate ( colon => index ( line , \":\" )) call assert ( adjustl ( line (: colon - 1 )) == '\"bias\"' , \"neuron_s(construct): neuron bias\" , line ) read ( line ( colon + 1 :), fmt =* ) neuron % bias_ end associate line = adjustl ( neuron_lines ( start + 3 )% string ()) call assert ( line ( 1 : 1 ) == '}' , \"neuron_s(construct): neuron object end\" , line ) line = adjustr ( neuron_lines ( start + 3 )% string ()) if ( line ( len ( line ): len ( line )) == \",\" ) neuron % next = construct ( neuron_lines , start + 4 ) end procedure module procedure weights my_weights = self % weights_ end procedure module procedure bias my_bias = self % bias_ end procedure module procedure next_allocated next_is_allocated = allocated ( self % next ) end procedure module procedure next_pointer next_ptr => self % next end procedure module procedure num_inputs size_weights = size ( self % weights_ ) end procedure end submodule neuron_s","tags":"","loc":"sourcefile/neuron_s.f90.html"},{"title":"tensor_range_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_range_s.f90~~EfferentGraph sourcefile~tensor_range_s.f90 tensor_range_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_range_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~tensor_range_s.f90->sourcefile~tensor_range_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_range_m ) tensor_range_s use assert_m , only : assert use julienne_m , only : separated_values use kind_parameters_m , only : rkind implicit none contains module procedure from_components call assert ( size ( minima ) == size ( maxima ), \"tensor_range_s(from_components): size(minima)==size(maxima)\" ) tensor_range % layer_ = layer tensor_range % minima_ = minima tensor_range % maxima_ = maxima end procedure module procedure from_json logical tensor_range_key_found integer l tensor_range_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"tensor_range\" ) then tensor_range_key_found = . true . tensor_range % layer_ = lines ( l + 1 )% get_json_value ( key = string_t ( \"layer\" ), mold = string_t ( \"\" )) tensor_range % minima_ = lines ( l + 2 )% get_json_value ( key = string_t ( \"minima\" ), mold = [ 0. ]) tensor_range % maxima_ = lines ( l + 3 )% get_json_value ( key = string_t ( \"maxima\" ), mold = [ 0. ]) return end if end do call assert ( tensor_range_key_found , \"tensor_range_s(from_json): 'tensor_range' key found\" ) end procedure module procedure equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % layer_ ) . and . allocated ( rhs % layer_ ), \"tensor_range_s(equals): allocated layer_ components\" ) call assert ( allocated ( lhs % minima_ ) . and . allocated ( rhs % minima_ ), \"tensor_range_s(equals): allocated minima_ components)\" ) call assert ( allocated ( lhs % maxima_ ) . and . allocated ( rhs % maxima_ ), \"tensor_range_s(equals): allocated maxima_ components)\" ) call assert ( size ( lhs % minima_ ) == size ( rhs % minima_ ), \"tensor_range_s(equals): size(lhs%minima_) == size(rhs%minima_)\" ) call assert ( size ( lhs % maxima_ ) == size ( rhs % maxima_ ), \"tensor_range_s(equals): size(lhs%maxima_) == size(rhs%maxima_)\" ) lhs_equals_rhs = & lhs % layer_ == rhs % layer_ . and . & all ( abs ( lhs % minima_ - rhs % minima_ ) <= tolerance ). and . & all ( abs ( lhs % maxima_ - rhs % maxima_ ) <= tolerance ) end procedure module procedure to_json integer , parameter :: characters_per_value = 17 character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) character ( len = :), allocatable :: csv_format , minima_string , maxima_string call assert ( allocated ( self % layer_ ), \"tensor_range_s(to_json): allocated layer_\" ) call assert ( allocated ( self % minima_ ) . and . allocated ( self % maxima_ ), \"tensor_range_s(to_json): allocated minima_/maxima_\" ) csv_format = separated_values ( separator = \",\" , mold = [ real ( rkind ) :: ]) allocate ( character ( len = size ( self % minima_ ) * ( characters_per_value + 1 ) - 1 ) :: minima_string ) allocate ( character ( len = size ( self % maxima_ ) * ( characters_per_value + 1 ) - 1 ) :: maxima_string ) write ( minima_string , fmt = csv_format ) self % minima_ write ( maxima_string , fmt = csv_format ) self % maxima_ lines = [ & string_t ( indent // '\"tensor_range\": {' ), & string_t ( indent // '  \"layer\": \"' // trim ( adjustl ( self % layer_ )) // '\",' ), & string_t ( indent // '  \"minima\": [' // trim ( adjustl ( minima_string )) // '],' ), & string_t ( indent // '  \"maxima\": [' // trim ( adjustl ( maxima_string )) // ']' ), & string_t ( indent // '}' ) & ] end procedure module procedure map_to_training_range associate ( tensor_values => tensor % values ()) associate ( normalized_values => ( tensor_values - self % minima_ ) / ( self % maxima_ - self % minima_ )) normalized_tensor = tensor_t ( normalized_values ) end associate end associate end procedure module procedure map_from_training_range associate ( tensor_values => tensor % values ()) associate ( unnormalized_values => self % minima_ + tensor_values * ( self % maxima_ - self % minima_ )) unnormalized_tensor = tensor_t ( unnormalized_values ) end associate end associate end procedure module procedure in_range is_in_range = all ( tensor % values () >= self % minima_ ) . and . all ( tensor % values () <= self % maxima_ ) end procedure end submodule tensor_range_s","tags":"","loc":"sourcefile/tensor_range_s.f90.html"},{"title":"network_configuration_s.F90 – Inference-Engine","text":"This file depends on sourcefile~~network_configuration_s.f90~~EfferentGraph sourcefile~network_configuration_s.f90 network_configuration_s.F90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~network_configuration_s.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( network_configuration_m ) network_configuration_s use assert_m , only : assert use julienne_formats_m , only : csv implicit none character ( len =* ), parameter :: skip_connections_key = \"skip connections\" character ( len =* ), parameter :: nodes_per_layer_key = \"nodes per layer\" character ( len =* ), parameter :: activation_name_key = \"activation function\" contains module procedure from_components network_configuration % skip_connections_ = skip_connections network_configuration % nodes_per_layer_ = nodes_per_layer network_configuration % activation_name_ = activation_name end procedure module procedure equals call assert ( allocated ( lhs % activation_name_ ) . and . allocated ( rhs % activation_name_ ), & \"network_configuration_s(equals): allocated({lhs,rhs}%activation_name_)\" ) lhs_equals_rhs = & lhs % skip_connections_ . eqv . rhs % skip_connections_ . and . & lhs % activation_name_ == rhs % activation_name_ . and . & all ( lhs % nodes_per_layer_ == rhs % nodes_per_layer_ ) end procedure module procedure from_json integer l logical network_configuration_key_found network_configuration_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"network configuration\" ) then network_configuration_key_found = . true . network_configuration % skip_connections_ = lines ( l + 1 )% get_json_value ( string_t ( skip_connections_key ), mold = . true .) network_configuration % nodes_per_layer_ = lines ( l + 2 )% get_json_value ( string_t ( nodes_per_layer_key ), mold = [ integer :: ]) network_configuration % activation_name_ = lines ( l + 3 )% get_json_value ( string_t ( activation_name_key ), mold = string_t ( \"\" )) return end if end do call assert ( network_configuration_key_found , \"network_configuration_s(from_json): network_configuration_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_logical_width = 6 , char_per_elem = 10 , brackets = 2 character ( len = max_logical_width ) skip_connections_string character ( len = :), allocatable :: nodes_per_layer_string allocate ( character ( len = size ( self % nodes_per_layer_ ) * char_per_elem + brackets ) :: nodes_per_layer_string ) #ifdef _CRAYFTN if ( self % skip_connections_ ) then write ( skip_connections_string , * ) \"true\" else write ( skip_connections_string , * ) \"false\" end if #else write ( skip_connections_string , * ) trim ( merge ( \"true \" , \"false\" , self % skip_connections_ )) #endif write ( nodes_per_layer_string , csv ) self % nodes_per_layer_ lines = [ & string_t ( indent // '\"network configuration\": {' ), & string_t ( indent // indent // '\"' // skip_connections_key // '\" : ' // trim ( adjustl ( skip_connections_string )) // ',' ), & string_t ( indent // indent // '\"' // nodes_per_layer_key // '\" : [' // trim ( adjustl ( nodes_per_layer_string )) // '],' ), & string_t ( indent // indent // '\"' // activation_name_key // '\" : \"' // trim ( adjustl ( self % activation_name_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure activation_name string = self % activation_name_ end procedure module procedure nodes_per_layer nodes = self % nodes_per_layer_ end procedure module procedure skip_connections using_skip = self % skip_connections_ end procedure end submodule network_configuration_s","tags":"","loc":"sourcefile/network_configuration_s.f90.html"},{"title":"activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~activation_strategy_m.f90~~EfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~activation_strategy_m.f90~~AfferentGraph sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~gelu_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~gelu_s.f90 gelu_s.f90 sourcefile~gelu_s.f90->sourcefile~gelu_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module activation_strategy_m ! External dependencies use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: activation_strategy_t public :: activation_i public :: function_name_i type , abstract :: activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation procedure ( function_name_i ), deferred :: function_name end type abstract interface elemental function activation_i ( x ) result ( y ) import rkind implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental function function_name_i ( self ) result ( string ) import string_t , activation_strategy_t implicit none class ( activation_strategy_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module activation_strategy_m","tags":"","loc":"sourcefile/activation_strategy_m.f90.html"},{"title":"swish_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_m.f90~~EfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~swish_m.f90~~AfferentGraph sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module swish_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: swish_t type , extends ( differentiable_activation_strategy_t ) :: swish_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( swish_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module swish_m","tags":"","loc":"sourcefile/swish_m.f90.html"},{"title":"input_output_pair_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_s.f90~~EfferentGraph sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( input_output_pair_m ) input_output_pair_s use assert_m , only : assert implicit none contains module procedure construct input_output_pair % inputs_ = inputs input_output_pair % expected_outputs_ = expected_outputs end procedure module procedure inputs my_inputs = self % inputs_ end procedure module procedure expected_outputs my_expected_outputs = self % expected_outputs_ end procedure module procedure shuffle type ( input_output_pair_t ) temp real harvest ( 2 : size ( pairs )) integer i , j call random_number ( harvest ) durstenfeld_shuffle : & do i = size ( pairs ), 2 , - 1 j = 1 + int ( harvest ( i ) * i ) temp = pairs ( i ) pairs ( i ) = pairs ( j ) pairs ( j ) = temp end do durstenfeld_shuffle end procedure end submodule input_output_pair_s","tags":"","loc":"sourcefile/input_output_pair_s.f90.html"},{"title":"step_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~step_s.f90~~EfferentGraph sourcefile~step_s.f90 step_s.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( step_m ) step_s use kind_parameters_m , only : rkind implicit none contains module procedure activation y = merge ( 1._rkind , 0._rkind , x > 0._rkind ) end procedure module procedure function_name string = string_t ( \"step\" ) end procedure end submodule step_s","tags":"","loc":"sourcefile/step_s.f90.html"},{"title":"relu_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~relu_m.f90~~EfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~relu_m.f90~~AfferentGraph sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module relu_m use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t use kind_parameters_m , only : rkind use julienne_string_m , only : string_t implicit none private public :: relu_t type , extends ( differentiable_activation_strategy_t ) :: relu_t contains procedure , nopass :: activation procedure , nopass :: activation_derivative procedure :: function_name end type interface elemental module function activation ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function activation_derivative ( x ) result ( y ) implicit none real ( rkind ), intent ( in ) :: x real ( rkind ) y end function elemental module function function_name ( self ) result ( string ) implicit none class ( relu_t ), intent ( in ) :: self type ( string_t ) string end function end interface end module relu_m","tags":"","loc":"sourcefile/relu_m.f90.html"},{"title":"swish_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~swish_s.f90~~EfferentGraph sourcefile~swish_s.f90 swish_s.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( swish_m ) swish_s use sigmoid_m , only : sigmoid_t implicit none contains module procedure activation type ( sigmoid_t ) sigmoid y = x * sigmoid % activation ( x ) end procedure module procedure activation_derivative type ( sigmoid_t ) sigmoid y = sigmoid % activation ( x ) + x * sigmoid % activation_derivative ( x ) end procedure module procedure function_name string = string_t ( \"swish\" ) end procedure end submodule swish_s","tags":"","loc":"sourcefile/swish_s.f90.html"},{"title":"learn-addition.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-addition.f90~~EfferentGraph sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module addition_m !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) + x ( 2 ), x ( 2 ) + x ( 3 ), x ( 3 ) + x ( 4 ), x ( 4 ) + x ( 5 ), x ( 5 ) + x ( 6 ), x ( 6 ) + x ( 8 )]) end associate end function end module program learn_addition !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use addition_m , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-addition --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-addition.f90.html"},{"title":"thompson_tensors_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~thompson_tensors_m.f90~~EfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~thompson_tensors_m.f90~~AfferentGraph sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module thompson_tensors_m !! This module supports the program in the file example/learn-microphysics-procedures.f90. use module_mp_thompson , only : rslf , rsif use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains elemental impure function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) associate ( temperature => T_min + ( T_max - T_min ) * x ( 1 ), pressure => p_min + ( p_max - p_min ) * x ( 2 ) ) a = tensor_t ([ rslf ( pressure , temperature ), rsif ( pressure , temperature )]) end associate end associate end function end module","tags":"","loc":"sourcefile/thompson_tensors_m.f90.html"},{"title":"saturated_mixing_ratio_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~saturated_mixing_ratio_m.f90~~EfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~saturated_mixing_ratio_m.f90~~AfferentGraph sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. module saturated_mixing_ratio_m !! This module supports the program in the file example/learn-saturated-mixing-ratio.f90. !! The saturated_mixing_ratio function in this module resulted from refactoring the sat_mr function !! in the Intermediate Complexity Atmospheric Research (ICAR) model file src/physics/mp_simple.f90. !! ICAR is distributed under the above MIT license.  See https://github.com/ncar/icar. use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none private public :: T , p , y real , parameter :: freezing_threshold = 27 3.15 ! [K] real , parameter :: T_min = 23 6.352524 , T_max = 30 7.610779 real , parameter :: p_min = 2967 1.1348 , p_max = 9859 6.7578 integer , parameter :: resolution = 10 integer i real , parameter :: T ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] real , parameter :: p ( * ) = [( real ( i ) / real ( resolution ), i = 0 , resolution )] contains pure function saturated_mixing_ratio ( T_normalized , p_normalized ) result ( sat_mr ) !! Calculate the saturated mixing ratio for normalized tempetatures (k) and pressures (Pa) real , intent ( in ) :: T_normalized , p_normalized real sat_mr associate ( & temperature => T_min + ( T_max - T_min ) * T_normalized , & pressure => p_min + ( p_max - p_min ) * p_normalized & ) associate ( below_freezing => temperature < freezing_threshold ) associate ( & a => merge ( 2 1.8745584 , 1 7.2693882 , below_freezing ), & b => merge ( 7.66 , 3 5.86 , below_freezing ) & ) associate ( p_threshold => 61 0.78 * exp ( a * ( temperature - 27 3.16 ) / ( temperature - b ))) !(Pa)) associate ( e_s => merge ( pressure * 0.99999 , p_threshold , ( pressure - p_threshold ) <= 0 )) sat_mr = 0.6219907 * e_s / ( pressure - e_s ) !(kg/kg) end associate end associate end associate end associate end associate end function elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( lbound ( x , 1 ) == 1 . and . ubound ( x , 1 ) == 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ saturated_mixing_ratio ( x ( 1 ), x ( 2 ))]) end associate end function end module","tags":"","loc":"sourcefile/saturated_mixing_ratio_m.f90.html"},{"title":"mp_thompson.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~mp_thompson.f90~~AfferentGraph sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt ! MIT License ! ! Copyright (c) 2017 National Center for Atmospheric Research ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. MODULE module_mp_thompson ! Adapted from https://github.com/BerkeleyLab/icar IMPLICIT NONE CONTAINS !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE LIQUID SATURATION VAPOR MIXING RATIO AS ! A FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSLF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESL , X REAL , PARAMETER :: C0 = . 61158369 9E03 REAL , PARAMETER :: C1 = . 44460689 6E02 REAL , PARAMETER :: C2 = . 14317715 7E01 REAL , PARAMETER :: C3 = . 26422432 1E-1 REAL , PARAMETER :: C4 = . 29929108 1E-3 REAL , PARAMETER :: C5 = . 20315418 2E-5 REAL , PARAMETER :: C6 = . 70262069 8E-8 REAL , PARAMETER :: C7 = . 37953431 0E-11 REAL , PARAMETER :: C8 =- . 32158239 3E-13 X = MAX ( - 8 0. , T - 27 3.16 ) !      ESL=612.2*EXP(17.67*X/(T-29.65)) ESL = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSLF = . 622 * ESL / ( P - ESL ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !    ESL = EXP(54.842763 - 6763.22 / T - 4.210 * ALOG(T) + 0.000367 * T !        + TANH(0.0415 * (T - 218.8)) * (53.878 - 1331.22 !        / T - 9.44523 * ALOG(T) + 0.014025 * T)) END FUNCTION RSLF !+---+-----------------------------------------------------------------+ ! THIS FUNCTION CALCULATES THE ICE SATURATION VAPOR MIXING RATIO AS A ! FUNCTION OF TEMPERATURE AND PRESSURE ! REAL FUNCTION RSIF ( P , T ) IMPLICIT NONE REAL , INTENT ( IN ) :: P , T REAL :: ESI , X REAL , PARAMETER :: C0 = . 60986899 3E03 REAL , PARAMETER :: C1 = . 49932023 3E02 REAL , PARAMETER :: C2 = . 18467263 1E01 REAL , PARAMETER :: C3 = . 40273718 4E-1 REAL , PARAMETER :: C4 = . 56539298 7E-3 REAL , PARAMETER :: C5 = . 52169393 3E-5 REAL , PARAMETER :: C6 = . 30783958 3E-7 REAL , PARAMETER :: C7 = . 10578516 0E-9 REAL , PARAMETER :: C8 = . 16144444 4E-12 X = MAX ( - 8 0. , T - 27 3.16 ) ESI = C0 + X * ( C1 + X * ( C2 + X * ( C3 + X * ( C4 + X * ( C5 + X * ( C6 + X * ( C7 + X * C8 ))))))) RSIF = . 622 * ESI / ( P - ESI ) !    ALTERNATIVE !  ; Source: Murphy and Koop, Review of the vapour pressure of ice and !             supercooled water for atmospheric applications, Q. J. R. !             Meteorol. Soc (2005), 131, pp. 1539-1565. !     ESI = EXP(9.550426 - 5723.265/T + 3.53068*ALOG(T) - 0.00728332*T) END FUNCTION RSIF !+---+-----------------------------------------------------------------+ !+---+-----------------------------------------------------------------+ END MODULE module_mp_thompson !+---+-----------------------------------------------------------------+","tags":"","loc":"sourcefile/mp_thompson.f90.html"},{"title":"tensor_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_m.f90~~EfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~tensor_m.f90~~AfferentGraph sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~tensor_range_s.f90 tensor_range_s.f90 sourcefile~tensor_range_s.f90->sourcefile~tensor_range_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module tensor_m use kind_parameters_m , only : rkind implicit none private public :: tensor_t type tensor_t private real ( rkind ), allocatable :: values_ (:) contains procedure values procedure num_components end type interface tensor_t pure module function construct_from_components ( values ) result ( tensor ) implicit none real ( rkind ), intent ( in ) :: values (:) type ( tensor_t ) tensor end function end interface interface pure module function values ( self ) result ( tensor_values ) implicit none class ( tensor_t ), intent ( in ) :: self real ( rkind ), allocatable :: tensor_values (:) end function pure module function num_components ( self ) result ( n ) implicit none class ( tensor_t ), intent ( in ) :: self integer n end function end interface end module tensor_m","tags":"","loc":"sourcefile/tensor_m.f90.html"},{"title":"learn-multiplication.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-multiplication.f90~~EfferentGraph sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module multiply_inputs !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_tensor ) result ( a_tensor ) type ( tensor_t ), intent ( in ) :: x_tensor type ( tensor_t ) a_tensor associate ( x => x_tensor % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a_tensor = tensor_t ([ x ( 1 ) * x ( 2 ), x ( 2 ) * x ( 3 ), x ( 3 ) * x ( 4 ), x ( 4 ) * x ( 5 ), x ( 5 ) * x ( 6 ), x ( 6 ) * x ( 8 )]) end associate end function end module program learn_multiplication !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use multiply_inputs , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-multiplication --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 200000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 64 , 64 , 64 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-multiplication.f90.html"},{"title":"learn-power-series.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-power-series.f90~~EfferentGraph sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module power_series !! Define a function that produces the desired network output for a given network input use inference_engine_m , only : tensor_t use assert_m , only : assert implicit none contains elemental function y ( x_in ) result ( a ) type ( tensor_t ), intent ( in ) :: x_in type ( tensor_t ) a associate ( x => x_in % values ()) call assert ( ubound ( x , 1 ) >= 7 . and . lbound ( x , 1 ) <= 2 , \"y(x) :: sufficient input\" ) a = tensor_t ([ 1 + x ( 1 ) + ( x ( 1 ) ** 2 ) / 2 + ( x ( 1 ) ** 3 ) / 6 , x ( 2 ), x ( 3 ), x ( 4 ), x ( 5 ), x ( 6 )]) end associate end function end module program learn_power_series !! This trains a neural network to learn the following six polynomial functions of its eight inputs. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t use power_series , only : y implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-power-series --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 10 , num_epochs = 10000 , num_mini_batches = 2 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) real white_noise ( 1 : num_inputs , 1 : num_pairs ) call random_number ( white_noise ) inputs = [( tensor_t ( real ([( white_noise ( j , i ), j = 1 , num_inputs )])), i = 1 , num_pairs )] desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print \"(a,69x,a)\" , \"  Outputs\" , \"| Desired outputs\" do p = 1 , num_pairs print \"(6G13.5, a1, 6G13.5)\" , network_outputs ( p )% values (), \"|\" , desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: n ( * ) = [ 8 , 196 , 196 , 196 , 196 , 6 ] integer , parameter :: n_max = maxval ( n ), layers = size ( n ) integer k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/learn-power-series.f90.html"},{"title":"learn-microphysics-procedures.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-microphysics-procedures.f90~~EfferentGraph sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~mp_thompson.f90 mp_thompson.f90 sourcefile~thompson_tensors_m.f90->sourcefile~mp_thompson.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program learn_microphysics_procedures !! Train a neural network proxies for procedures in the Thompson microphysics model !! in of ICAR (https://github.com/BerkeleyLab/icar). use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , sigmoid_t use julienne_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use thompson_tensors_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run learn-microphysics-procedures --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 10 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 2 ] real , parameter :: cost_tolerance = 1.E-08 call random_init ( image_distinct = . true ., repeatable = . true .) open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print * , \" Inputs (normalized)          | Outputs                    | Desired outputs\" do p = 1 , num_pairs print \"(6(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = sigmoid_t (), & metadata = & [ string_t ( \"Thompson microphysics procedures\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"sigmoid\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-microphysics-procedures.f90.html"},{"title":"train-and-write.F90 – Inference-Engine","text":"This file depends on sourcefile~~train-and-write.f90~~EfferentGraph sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_and_write !! This program demonstrates how to train a simple neural network starting from a randomized initial condition and !! how to write the initial network and the trained network to separate JSON files.  The network has two hiden layers. !! The input, hidden, and output layers are all two nodes wide.  The training data has outputs that identically match !! the corresponding inputs.  Hence, the desired network represents an identity mapping.  With RELU activation functions, !! the desired network therefore contains weights corresponding to identity matrices and biases that vanish everywhere. !! The initial condition corresponds to the desired network with all weights and biases perturbed by a random variable !! that is uniformly distributed on the range [0,0.1]. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t use assert_m , only : assert , intrinsic_array_t implicit none type ( string_t ) final_network_file type ( command_line_t ) command_line final_network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( final_network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example train-and-write --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if block integer , parameter :: num_pairs = 5 , num_epochs = 500 , num_mini_batches = 3 ! num_pairs =  # input/output pairs in training data type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) call random_init ( image_distinct = . true ., repeatable = . true .) trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.2 ) call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) call assert ( num_inputs == num_outputs , \"trainable_engine_test_m(identity_mapping): # inputs == # outputs\" , & intrinsic_array_t ([ num_inputs , num_outputs ]) & ) block integer i , j inputs = [( tensor_t ( real ([( j * i , j = 1 , num_inputs )]) / ( num_inputs * num_pairs )), i = 1 , num_pairs )] end block associate ( outputs => inputs ) input_output_pairs = input_output_pair_t ( inputs , outputs ) end associate block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block allocate ( random_numbers ( 2 : size ( input_output_pairs ))) print * , \"Cost\" block integer e , b do e = 1 , num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) print * , sum ( cost ) / size ( cost ) end do end block block real , parameter :: tolerance = 1.E-06 integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print * , \" Outputs                          |& Desired outputs                    |& Errors\" do p = 1 , num_pairs print * , network_outputs ( p )% values (), \"|\" , inputs ( p )% values (), \"|\" , network_outputs ( p )% values () - inputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block end associate call output ( trainable_engine % to_inference_engine (), final_network_file ) end block contains subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine function perturbed_identity_network ( perturbation_magnitude ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) integer i real , parameter :: identity ( * , * , * ) = & reshape ( real ([( [ 1 , 0 ], [ 0 , 1 ], i = 1 , layers - 1 )]), [ max_n , max_n , layers - 1 ]) real w_harvest ( size ( identity , 1 ), size ( identity , 2 ), size ( identity , 3 )), b_harvest ( size ( identity , 1 ), size ( identity , 3 )) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = nodes_per_layer , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Perturbed Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), string_t ( \"false\" )] & ) end associate end function end program","tags":"","loc":"sourcefile/train-and-write.f90.html"},{"title":"tensor_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~tensor_s.f90~~EfferentGraph sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( tensor_m ) tensor_s implicit none contains module procedure construct_from_components tensor % values_ = values end procedure module procedure values tensor_values = self % values_ end procedure module procedure num_components n = size ( self % values_ ) end procedure end submodule tensor_s","tags":"","loc":"sourcefile/tensor_s.f90.html"},{"title":"ubounds_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~ubounds_m.f90~~AfferentGraph sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module ubounds_m !! This module serves only to support array bounds checking in the main program below implicit none type ubounds_t integer , allocatable :: ubounds_ (:) contains procedure equals generic :: operator ( == ) => equals end type contains elemental function equals ( lhs , rhs ) result ( lhs_equals_rhs ) class ( ubounds_t ), intent ( in ) :: lhs , rhs logical lhs_equals_rhs lhs_equals_rhs = all ( lhs % ubounds_ == rhs % ubounds_ ) end function end module","tags":"","loc":"sourcefile/ubounds_m.f90.html"},{"title":"differentiable_activation_strategy_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~differentiable_activation_strategy_m.f90~~EfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~differentiable_activation_strategy_m.f90~~AfferentGraph sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~gelu_s.f90 gelu_s.f90 sourcefile~gelu_s.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module differentiable_activation_strategy_m use activation_strategy_m , only : activation_strategy_t , activation_i implicit none private public :: differentiable_activation_strategy_t type , extends ( activation_strategy_t ), abstract :: differentiable_activation_strategy_t contains procedure ( activation_i ), nopass , deferred :: activation_derivative end type end module differentiable_activation_strategy_m","tags":"","loc":"sourcefile/differentiable_activation_strategy_m.f90.html"},{"title":"training_configuration_s.F90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_s.f90~~EfferentGraph sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( training_configuration_m ) training_configuration_s use assert_m , only : assert use inference_engine_m , only : gelu_t , relu_t , sigmoid_t , swish_t implicit none character ( len =* ), parameter :: header = \"{\" , footer = \"}\" , separator = \",\" contains module procedure from_components training_configuration % hyperparameters_ = hyperparameters training_configuration % network_configuration_ = network_configuration training_configuration % file_t = file_t ([ & string_t ( header ), & training_configuration % hyperparameters_ % to_json (), & string_t ( separator ), & training_configuration % network_configuration_ % to_json (), & string_t ( footer ) & ]) end procedure module procedure from_file integer , parameter :: hyperparameters_start = 2 , hyperparameters_end = 6 , separator_line = 7 ! line numbers integer , parameter :: net_config_start = 8 , net_config_end = 12 ! line numbers integer , parameter :: file_start = hyperparameters_start - 1 , file_end = net_config_end + 1 ! line numbers #if defined __INTEL_COMPILER || _CRAYFTN type ( string_t ), allocatable :: lines (:) #endif training_configuration % file_t = file_object #if defined __INTEL_COMPILER || _CRAYFTN lines = training_configuration % file_t % lines () #else associate ( lines => training_configuration % file_t % lines ()) #endif call assert ( trim ( adjustl ( lines ( file_start )% string ())) == header , \"training_configuration_s(from_file): header\" , lines ( file_start )) training_configuration % hyperparameters_ = hyperparameters_t ( lines ( hyperparameters_start : hyperparameters_end )) call assert ( trim ( adjustl ( lines ( separator_line )% string ())) == separator , \"training_configuration_s(from_file): separator\" , & lines ( file_start )) training_configuration % network_configuration_ = network_configuration_t ( lines ( net_config_start : net_config_end )) call assert ( trim ( adjustl ( lines ( file_end )% string ())) == footer , \"training_configuration_s(from_file): footer\" , lines ( file_end )) #if defined __INTEL_COMPILER || _CRAYFTN #else end associate #endif end procedure module procedure to_json json_lines = self % lines () end procedure module procedure equals lhs_eq_rhs = & lhs % hyperparameters_ == rhs % hyperparameters_ . and . & lhs % network_configuration_ == rhs % network_configuration_ end procedure module procedure mini_batches num_mini_batches = self % hyperparameters_ % mini_batches () end procedure module procedure optimizer_name identifier = self % hyperparameters_ % optimizer_name () end procedure module procedure learning_rate rate = self % hyperparameters_ % learning_rate () end procedure module procedure nodes_per_layer nodes = self % network_configuration_ % nodes_per_layer () end procedure module procedure skip_connections using_skip = self % network_configuration_ % skip_connections () end procedure module procedure differentiable_activation_strategy #if defined __INTEL_COMPILER || _CRAYFTN type ( string_t ) :: activation_name activation_name = self % network_configuration_ % activation_name () #else associate ( activation_name => self % network_configuration_ % activation_name ()) #endif select case ( activation_name % string ()) case ( \"gelu\" ) strategy = gelu_t () case ( \"relu\" ) strategy = relu_t () case ( \"sigmoid\" ) strategy = sigmoid_t () case ( \"swish\" ) strategy = swish_t () case default error stop 'activation_strategy_factory_s(factory): unrecognized activation name \"' // activation_name % string () // '\"' end select #if defined __INTEL_COMPILER || _CRAYFTN #else end associate #endif end procedure end submodule training_configuration_s","tags":"","loc":"sourcefile/training_configuration_s.f90.html"},{"title":"training_configuration_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~training_configuration_m.f90~~EfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~training_configuration_m.f90~~AfferentGraph sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module training_configuration_m use julienne_string_m , only : string_t use julienne_file_m , only : file_t use hyperparameters_m , only : hyperparameters_t use network_configuration_m , only : network_configuration_t use kind_parameters_m , only : rkind use differentiable_activation_strategy_m , only : differentiable_activation_strategy_t implicit none private public :: training_configuration_t type , extends ( file_t ) :: training_configuration_t private type ( hyperparameters_t ) hyperparameters_ type ( network_configuration_t ) network_configuration_ contains procedure :: to_json procedure :: equals generic :: operator ( == ) => equals procedure :: mini_batches procedure :: optimizer_name procedure :: learning_rate procedure :: differentiable_activation_strategy procedure :: nodes_per_layer procedure :: skip_connections end type interface training_configuration_t module function from_components ( hyperparameters , network_configuration ) result ( training_configuration ) implicit none type ( hyperparameters_t ), intent ( in ) :: hyperparameters type ( network_configuration_t ), intent ( in ) :: network_configuration type ( training_configuration_t ) training_configuration end function module function from_file ( file_object ) result ( training_configuration ) implicit none type ( file_t ), intent ( in ) :: file_object type ( training_configuration_t ) training_configuration end function end interface interface pure module function to_json ( self ) result ( json_lines ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ), allocatable :: json_lines (:) end function elemental module function equals ( lhs , rhs ) result ( lhs_eq_rhs ) implicit none class ( training_configuration_t ), intent ( in ) :: lhs , rhs logical lhs_eq_rhs end function elemental module function mini_batches ( self ) result ( num_mini_batches ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer num_mini_batches end function elemental module function optimizer_name ( self ) result ( identifier ) implicit none class ( training_configuration_t ), intent ( in ) :: self type ( string_t ) identifier end function elemental module function learning_rate ( self ) result ( rate ) implicit none class ( training_configuration_t ), intent ( in ) :: self real ( rkind ) rate end function module function differentiable_activation_strategy ( self ) result ( strategy ) implicit none class ( training_configuration_t ), intent ( in ) :: self class ( differentiable_activation_strategy_t ), allocatable :: strategy end function pure module function nodes_per_layer ( self ) result ( nodes ) implicit none class ( training_configuration_t ), intent ( in ) :: self integer , allocatable :: nodes (:) end function elemental module function skip_connections ( self ) result ( using_skip ) implicit none class ( training_configuration_t ), intent ( in ) :: self logical using_skip end function end interface end module","tags":"","loc":"sourcefile/training_configuration_m.f90.html"},{"title":"mini_batch_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~mini_batch_s.f90~~EfferentGraph sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt submodule ( mini_batch_m ) mini_batch_s implicit none contains module procedure construct mini_batch % input_output_pairs_ = input_output_pairs end procedure module procedure input_output_pairs my_input_output_pairs = self % input_output_pairs_ end procedure end submodule mini_batch_s","tags":"","loc":"sourcefile/mini_batch_s.f90.html"},{"title":"kind_parameters_m.f90 – Inference-Engine","text":"Files dependent on this one sourcefile~~kind_parameters_m.f90~~AfferentGraph sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_s.f90 gelu_s.f90 sourcefile~gelu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~gelu_s.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~layer_m.f90 layer_m.f90 sourcefile~layer_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~layer_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~neuron_m.f90 neuron_m.f90 sourcefile~layer_m.f90->sourcefile~neuron_m.f90 sourcefile~layer_m.f90->sourcefile~tensor_range_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~neuron_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_s.f90 relu_s.f90 sourcefile~relu_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_s.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_s.f90 step_s.f90 sourcefile~step_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_s.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_s.f90 tensor_range_s.f90 sourcefile~tensor_range_s.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_s.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_s.f90 inference_engine_s.F90 sourcefile~inference_engine_s.f90->sourcefile~gelu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~inference_engine_m_.f90 sourcefile~inference_engine_s.f90->sourcefile~layer_m.f90 sourcefile~inference_engine_s.f90->sourcefile~neuron_m.f90 sourcefile~inference_engine_s.f90->sourcefile~relu_m.f90 sourcefile~inference_engine_s.f90->sourcefile~sigmoid_m.f90 sourcefile~inference_engine_s.f90->sourcefile~step_m.f90 sourcefile~inference_engine_s.f90->sourcefile~swish_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~layer_s.f90 layer_s.f90 sourcefile~layer_s.f90->sourcefile~layer_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~neuron_s.f90 neuron_s.f90 sourcefile~neuron_s.f90->sourcefile~neuron_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~sigmoid_s.f90 sigmoid_s.f90 sourcefile~sigmoid_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90 swish_s.f90 sourcefile~swish_s.f90->sourcefile~sigmoid_m.f90 sourcefile~swish_s.f90->sourcefile~swish_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_s.f90 tensor_s.f90 sourcefile~tensor_s.f90->sourcefile~tensor_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~training_configuration_s.f90->sourcefile~training_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module kind_parameters_m implicit none private public :: rkind integer , parameter :: rkind = kind ( 1.0 ) end module kind_parameters_m","tags":"","loc":"sourcefile/kind_parameters_m.f90.html"},{"title":"concurrent-inferences.f90 – Inference-Engine","text":"This file depends on sourcefile~~concurrent-inferences.f90~~EfferentGraph sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program concurrent_inferences !! This program demonstrates how to read a neural network from a JSON file !! and use the network to perform concurrent inferences. use inference_engine_m , only : inference_engine_t , tensor_t , infer use julienne_m , only : string_t , command_line_t , file_t use assert_m , only : assert use iso_fortran_env , only : int64 , real64 implicit none type ( string_t ) network_file_name type ( command_line_t ) command_line network_file_name = string_t ( command_line % flag_value ( \"--network\" )) if ( len ( network_file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example concurrent-inferences --profile release --flag \"-fopenmp\" -- --network \"<file-name>\"' end if block type ( inference_engine_t ) network , inference_engine type ( tensor_t ), allocatable :: inputs (:,:,:), outputs (:,:,:) real , allocatable :: input_components (:,:,:,:) integer , parameter :: lat = 263 , lon = 317 , lev = 15 ! latitudes, longitudes, levels (elevations) integer i , j , k print * , \"Constructing a new inference_engine_t object from the file \" // network_file_name % string () inference_engine = inference_engine_t ( file_t ( network_file_name )) print * , \"Defining an array of tensor_t input objects with random normalized components\" allocate ( inputs ( lat , lon , lev )) allocate ( input_components ( lat , lon , lev , inference_engine % num_inputs ())) call random_number ( input_components ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) inputs ( i , j , k ) = tensor_t ( input_components ( i , j , k ,:)) end do block integer ( int64 ) t_start , t_finish , clock_rate print * , \"Performing elemental inferences\" call system_clock ( t_start , clock_rate ) outputs = inference_engine % infer ( inputs ) ! implicit allocation of outputs array call system_clock ( t_finish ) print * , \"Elemental inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) call assert ( all ( shape ( outputs ) == shape ( inputs )), \"all(shape(outputs) == shape(inputs))\" ) print * , \"Performing loop-based inference\" call system_clock ( t_start ) do k = 1 , lev do j = 1 , lon do i = 1 , lat outputs ( i , j , k ) = inference_engine % infer ( inputs ( i , j , k )) end do end do end do call system_clock ( t_finish ) print * , \"Looping inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing concurrent inference\" call system_clock ( t_start ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = inference_engine % infer ( inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Concurrent inference time: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) print * , \"Performing concurrent inference with a non-type-bound inference procedure\" call system_clock ( t_start ) do concurrent ( i = 1 : lat , j = 1 : lon , k = 1 : lev ) outputs ( i , j , k ) = infer ( inference_engine , inputs ( i , j , k )) end do call system_clock ( t_finish ) print * , \"Concurrent inference time with non-type-bound procedure: \" , real ( t_finish - t_start , real64 ) / real ( clock_rate , real64 ) end block end block end program","tags":"","loc":"sourcefile/concurrent-inferences.f90.html"},{"title":"input_output_pair_m.f90 – Inference-Engine","text":"This file depends on sourcefile~~input_output_pair_m.f90~~EfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~input_output_pair_m.f90~~AfferentGraph sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~input_output_pair_s.f90 input_output_pair_s.f90 sourcefile~input_output_pair_s.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~concurrent-inferences.f90 concurrent-inferences.f90 sourcefile~concurrent-inferences.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-addition.f90 learn-addition.F90 sourcefile~learn-addition.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-exponentiation.f90 learn-exponentiation.F90 sourcefile~learn-exponentiation.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-microphysics-procedures.f90 learn-microphysics-procedures.F90 sourcefile~learn-microphysics-procedures.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90 thompson_tensors_m.f90 sourcefile~learn-microphysics-procedures.f90->sourcefile~thompson_tensors_m.f90 sourcefile~learn-multiplication.f90 learn-multiplication.F90 sourcefile~learn-multiplication.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-power-series.f90 learn-power-series.F90 sourcefile~learn-power-series.f90->sourcefile~inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~mini_batch_s.f90 mini_batch_s.f90 sourcefile~mini_batch_s.f90->sourcefile~mini_batch_m.f90 sourcefile~print-training-configuration.f90 print-training-configuration.F90 sourcefile~print-training-configuration.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~thompson_tensors_m.f90->sourcefile~inference_engine_m.f90 sourcefile~train-and-write.f90 train-and-write.F90 sourcefile~train-and-write.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~training_configuration_s.f90 training_configuration_s.F90 sourcefile~training_configuration_s.f90->sourcefile~inference_engine_m.f90 sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~trainable_engine_s.f90 trainable_engine_s.F90 sourcefile~trainable_engine_s.f90->sourcefile~trainable_engine_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt module input_output_pair_m use kind_parameters_m , only : rkind use tensor_m , only : tensor_t implicit none private public :: input_output_pair_t public :: shuffle type input_output_pair_t private type ( tensor_t ) inputs_ , expected_outputs_ contains procedure :: inputs procedure :: expected_outputs end type interface input_output_pair_t elemental module function construct ( inputs , expected_outputs ) result ( input_output_pair ) implicit none type ( tensor_t ), intent ( in ) :: inputs , expected_outputs type ( input_output_pair_t ) input_output_pair end function end interface interface elemental module function inputs ( self ) result ( my_inputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_inputs end function elemental module function expected_outputs ( self ) result ( my_expected_outputs ) implicit none class ( input_output_pair_t ), intent ( in ) :: self type ( tensor_t ) :: my_expected_outputs end function module subroutine shuffle ( pairs ) implicit none type ( input_output_pair_t ), intent ( inout ) :: pairs (:) end subroutine end interface end module input_output_pair_m","tags":"","loc":"sourcefile/input_output_pair_m.f90.html"},{"title":"learn-saturated-mixing-ratio.F90 – Inference-Engine","text":"This file depends on sourcefile~~learn-saturated-mixing-ratio.f90~~EfferentGraph sourcefile~learn-saturated-mixing-ratio.f90 learn-saturated-mixing-ratio.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~inference_engine_m.f90 sourcefile~saturated_mixing_ratio_m.f90 saturated_mixing_ratio_m.f90 sourcefile~learn-saturated-mixing-ratio.f90->sourcefile~saturated_mixing_ratio_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~saturated_mixing_ratio_m.f90->sourcefile~inference_engine_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program train_saturated_mixture_ratio !! This program trains a neural network to learn the saturated mixing ratio function of ICAR. use inference_engine_m , only : & inference_engine_t , trainable_engine_t , mini_batch_t , tensor_t , input_output_pair_t , shuffle , relu_t use julienne_m , only : string_t , file_t , command_line_t , bin_t , csv use assert_m , only : assert , intrinsic_array_t use saturated_mixing_ratio_m , only : y , T , p use iso_fortran_env , only : int64 , output_unit implicit none type ( string_t ) network_file type ( command_line_t ) command_line integer ( int64 ) counter_start , counter_end , clock_rate network_file = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( network_file % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example learn-saturated-mixing-ratio --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call system_clock ( counter_start , clock_rate ) block integer , parameter :: max_num_epochs = 10000000 , num_mini_batches = 6 integer num_pairs ! number of input/output pairs type ( mini_batch_t ), allocatable :: mini_batches (:) type ( input_output_pair_t ), allocatable :: input_output_pairs (:) type ( tensor_t ), allocatable :: inputs (:), desired_outputs (:) type ( trainable_engine_t ) trainable_engine type ( bin_t ), allocatable :: bins (:) real , allocatable :: cost (:), random_numbers (:) integer io_status , network_unit , plot_unit integer , parameter :: io_success = 0 , diagnostics_print_interval = 1000 , network_save_interval = 10000 integer , parameter :: nodes_per_layer ( * ) = [ 2 , 72 , 1 ] real , parameter :: cost_tolerance = 1.E-08 call random_init ( image_distinct = . true ., repeatable = . true .) open ( newunit = network_unit , file = network_file % string (), form = 'formatted' , status = 'old' , iostat = io_status , action = 'read' ) if ( io_status == io_success ) then print * , \"Reading network from file \" // network_file % string () trainable_engine = trainable_engine_t ( inference_engine_t ( file_t ( network_file ))) close ( network_unit ) else close ( network_unit ) print * , \"Initializing a new network\" trainable_engine = perturbed_identity_network ( perturbation_magnitude = 0.05 , n = nodes_per_layer ) end if call output ( trainable_engine % to_inference_engine (), string_t ( \"initial-network.json\" )) associate ( num_inputs => trainable_engine % num_inputs (), num_outputs => trainable_engine % num_outputs ()) block integer i , j integer , allocatable :: output_sizes (:) inputs = [( [( tensor_t ([ T ( i ), p ( j )]), j = 1 , size ( p ))], i = 1 , size ( T ))] num_pairs = size ( inputs ) call assert ( num_pairs == size ( T ) * size ( p ), \"train_cloud_microphysics: inputs tensor array complete\" ) desired_outputs = y ( inputs ) output_sizes = [( size ( desired_outputs ( i )% values ()), i = 1 , size ( desired_outputs ))] call assert ( all ([ num_outputs == output_sizes ]), \"fit-polynomials: # outputs\" , intrinsic_array_t ([ num_outputs , output_sizes ])) end block input_output_pairs = input_output_pair_t ( inputs , desired_outputs ) block integer b bins = [( bin_t ( num_items = num_pairs , num_bins = num_mini_batches , bin_number = b ), b = 1 , num_mini_batches )] end block block integer e , b , stop_unit , previous_epoch real previous_clock_time call open_plot_file_for_appending ( \"cost.plt\" , plot_unit , previous_epoch , previous_clock_time ) print * , \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" allocate ( random_numbers ( 2 : size ( input_output_pairs ))) do e = previous_epoch + 1 , previous_epoch + max_num_epochs call random_number ( random_numbers ) call shuffle ( input_output_pairs ) mini_batches = [( mini_batch_t ( input_output_pairs ( bins ( b )% first (): bins ( b )% last ())), b = 1 , size ( bins ))] call trainable_engine % train ( mini_batches , cost , adam = . true ., learning_rate = 1.5 ) call system_clock ( counter_end , clock_rate ) associate ( & cost_avg => sum ( cost ) / size ( cost ), & cumulative_clock_time => previous_clock_time + real ( counter_end - counter_start ) / real ( clock_rate ), & loop_ending => e == previous_epoch + max_num_epochs & ) write_and_exit_if_converged : & if ( cost_avg < cost_tolerance ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_converged open ( newunit = stop_unit , file = \"stop\" , form = 'formatted' , status = 'old' , iostat = io_status ) write_and_exit_if_stop_file_exists : & if ( io_status == 0 ) then call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) call output ( trainable_engine % to_inference_engine (), network_file ) exit end if write_and_exit_if_stop_file_exists if ( mod ( e , diagnostics_print_interval ) == 0 . or . loop_ending ) & call print_diagnostics ( plot_unit , e , cost_avg , cumulative_clock_time , nodes_per_layer ) if ( mod ( e , network_save_interval ) == 0 . or . loop_ending ) call output ( trainable_engine % to_inference_engine (), network_file ) end associate end do close ( plot_unit ) report_network_performance : & block integer p #if defined _CRAYFTN || __GFORTRAN__ type ( tensor_t ), allocatable :: network_outputs (:) network_outputs = trainable_engine % infer ( inputs ) #else associate ( network_outputs => trainable_engine % infer ( inputs )) #endif print * , \"Inputs (normalized)          | Outputs      | Desired outputs\" do p = 1 , num_pairs print \"(4(G13.5,2x))\" , inputs ( p )% values (), network_outputs ( p )% values (), desired_outputs ( p )% values () end do #if defined _CRAYFTN || __GFORTRAN__ #else end associate #endif end block report_network_performance end block end associate call output ( trainable_engine % to_inference_engine (), network_file ) end block contains subroutine print_diagnostics ( plot_file_unit , epoch , cost , clock , nodes ) integer , intent ( in ) :: plot_file_unit , epoch , nodes (:) real , intent ( in ) :: cost , clock write ( unit = output_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = output_unit , fmt = csv ) nodes write ( unit = plot_file_unit , fmt = '(3(g13.5,2x))' , advance = 'no' ) epoch , cost , clock write ( unit = plot_file_unit , fmt = csv ) nodes end subroutine subroutine output ( inference_engine , file_name ) type ( inference_engine_t ), intent ( in ) :: inference_engine type ( string_t ), intent ( in ) :: file_name type ( file_t ) json_file json_file = inference_engine % to_json () call json_file % write_lines ( file_name ) end subroutine pure function e ( j , n ) result ( unit_vector ) integer , intent ( in ) :: j , n integer k real , allocatable :: unit_vector (:) unit_vector = real ([( merge ( 1 , 0 , j == k ), k = 1 , n )]) end function function perturbed_identity_network ( perturbation_magnitude , n ) result ( trainable_engine ) type ( trainable_engine_t ) trainable_engine real , intent ( in ) :: perturbation_magnitude integer , intent ( in ) :: n (:) integer j , k , l real , allocatable :: identity (:,:,:), w_harvest (:,:,:), b_harvest (:,:) associate ( n_max => maxval ( n ), layers => size ( n )) identity = reshape ( [( [( e ( k , n_max ), k = 1 , n_max )], l = 1 , layers - 1 )], [ n_max , n_max , layers - 1 ]) allocate ( w_harvest , mold = identity ) allocate ( b_harvest ( size ( identity , 1 ), size ( identity , 3 ))) call random_number ( w_harvest ) call random_number ( b_harvest ) associate ( w => identity + perturbation_magnitude * ( w_harvest - 0.5 ) / 0.5 , b => perturbation_magnitude * ( b_harvest - 0.5 ) / 0.5 ) trainable_engine = trainable_engine_t ( & nodes = n , weights = w , biases = b , differentiable_activation_strategy = relu_t (), & metadata = & [ string_t ( \"Saturated Mixing Ratio\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-23\" ), string_t ( \"relu\" ), & string_t ( \"false\" )] & ) end associate end associate end function subroutine open_plot_file_for_appending ( plot_file_name , plot_unit , previous_epoch , previous_clock ) character ( len =* ), intent ( in ) :: plot_file_name integer , intent ( out ) :: plot_unit , previous_epoch real , intent ( out ) :: previous_clock type ( file_t ) plot_file type ( string_t ), allocatable :: lines (:) character ( len = :), allocatable :: last_line integer io_status integer , parameter :: io_success = 0 logical preexisting_plot_file real cost inquire ( file = plot_file_name , exist = preexisting_plot_file ) open ( newunit = plot_unit , file = \"cost.plt\" , status = \"unknown\" , position = \"append\" ) associate ( header => \"        Epoch | Cost Function| System_Clock | Nodes per Layer\" ) if (. not . preexisting_plot_file ) then write ( plot_unit , * ) header previous_epoch = 0 previous_clock = 0 else plot_file = file_t ( string_t ( plot_file_name )) lines = plot_file % lines () last_line = lines ( size ( lines ))% string () read ( last_line , * , iostat = io_status ) previous_epoch , cost , previous_clock if (( io_status /= io_success . and . last_line == header ) . or . len ( trim ( last_line )) == 0 ) then previous_epoch = 0 previous_clock = 0 end if end if end associate end subroutine end program","tags":"","loc":"sourcefile/learn-saturated-mixing-ratio.f90.html"},{"title":"hyperparameters_s.f90 – Inference-Engine","text":"This file depends on sourcefile~~hyperparameters_s.f90~~EfferentGraph sourcefile~hyperparameters_s.f90 hyperparameters_s.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~hyperparameters_s.f90->sourcefile~hyperparameters_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( hyperparameters_m ) hyperparameters_s use assert_m , only : assert implicit none character ( len =* ), parameter :: mini_batches_key = \"mini-batches\" character ( len =* ), parameter :: learning_rate_key = \"learning rate\" character ( len =* ), parameter :: optimizer_key = \"optimizer\" contains module procedure from_components hyperparameters % mini_batches_ = mini_batches hyperparameters % learning_rate_ = learning_rate hyperparameters % optimizer_ = optimizer end procedure module procedure equals real , parameter :: tolerance = 1.E-08 call assert ( allocated ( lhs % optimizer_ ) . and . allocated ( rhs % optimizer_ ), \"hyperparameters_s(equals): allocated optimizers\" ) lhs_equals_rhs = & lhs % mini_batches_ == rhs % mini_batches_ . and . & lhs % optimizer_ == rhs % optimizer_ . and . & abs ( lhs % learning_rate_ - rhs % learning_rate_ ) <= tolerance end procedure module procedure from_json integer l logical hyperparameters_key_found hyperparameters_key_found = . false . do l = 1 , size ( lines ) if ( lines ( l )% get_json_key () == \"hyperparameters\" ) then hyperparameters_key_found = . true . hyperparameters % mini_batches_ = lines ( l + 1 )% get_json_value ( string_t ( mini_batches_key ), mold = 0 ) hyperparameters % learning_rate_ = lines ( l + 2 )% get_json_value ( string_t ( learning_rate_key ), mold = 0. ) hyperparameters % optimizer_ = lines ( l + 3 )% get_json_value ( string_t ( optimizer_key ), mold = string_t ( \"\" )) return end if end do call assert ( hyperparameters_key_found , \"hyperparameters_s(from_json): hyperparameters_found\" ) end procedure module procedure to_json character ( len =* ), parameter :: indent = repeat ( \" \" , ncopies = 4 ) integer , parameter :: max_width = 18 character ( len = max_width ) mini_batches_string , learning_rate_string write ( mini_batches_string , * ) self % mini_batches_ write ( learning_rate_string , * ) self % learning_rate_ lines = [ & string_t ( indent // '\"hyperparameters\": {' ), & string_t ( indent // indent // '\"' // mini_batches_key // '\" : ' // trim ( adjustl ( mini_batches_string )) // \",\" ), & string_t ( indent // indent // '\"' // learning_rate_key // '\" : ' // trim ( adjustl ( learning_rate_string )) // \",\" ), & string_t ( indent // indent // '\"' // optimizer_key // '\" : \"' // trim ( adjustl ( self % optimizer_ )) // '\"' ), & string_t ( indent // '}' ) & ] end procedure module procedure mini_batches num_mini_batches = self % mini_batches_ end procedure module procedure optimizer_name identifier = string_t ( self % optimizer_ ) end procedure module procedure learning_rate rate = self % learning_rate_ end procedure end submodule hyperparameters_s","tags":"","loc":"sourcefile/hyperparameters_s.f90.html"},{"title":"write-read-infer.F90 – Inference-Engine","text":"This file depends on sourcefile~~write-read-infer.f90~~EfferentGraph sourcefile~write-read-infer.f90 write-read-infer.F90 sourcefile~inference_engine_m.f90 inference_engine_m.f90 sourcefile~write-read-infer.f90->sourcefile~inference_engine_m.f90 sourcefile~kind_parameters_m.f90 kind_parameters_m.f90 sourcefile~write-read-infer.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~activation_strategy_m.f90 activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~differentiable_activation_strategy_m.f90 differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~gelu_m.f90 gelu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~gelu_m.f90 sourcefile~hyperparameters_m.f90 hyperparameters_m.f90 sourcefile~inference_engine_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~inference_engine_m_.f90 inference_engine_m_.f90 sourcefile~inference_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~input_output_pair_m.f90 input_output_pair_m.f90 sourcefile~inference_engine_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~mini_batch_m.f90 mini_batch_m.f90 sourcefile~inference_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~network_configuration_m.f90 network_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~network_configuration_m.f90 sourcefile~relu_m.f90 relu_m.f90 sourcefile~inference_engine_m.f90->sourcefile~relu_m.f90 sourcefile~sigmoid_m.f90 sigmoid_m.f90 sourcefile~inference_engine_m.f90->sourcefile~sigmoid_m.f90 sourcefile~step_m.f90 step_m.f90 sourcefile~inference_engine_m.f90->sourcefile~step_m.f90 sourcefile~swish_m.f90 swish_m.f90 sourcefile~inference_engine_m.f90->sourcefile~swish_m.f90 sourcefile~tensor_m.f90 tensor_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~tensor_range_m.f90 tensor_range_m.f90 sourcefile~inference_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90 trainable_engine_m.F90 sourcefile~inference_engine_m.f90->sourcefile~trainable_engine_m.f90 sourcefile~training_configuration_m.f90 training_configuration_m.f90 sourcefile~inference_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~ubounds_m.f90 ubounds_m.f90 sourcefile~inference_engine_m.f90->sourcefile~ubounds_m.f90 sourcefile~activation_strategy_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~differentiable_activation_strategy_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~gelu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~gelu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~hyperparameters_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~kind_parameters_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_m.f90 sourcefile~inference_engine_m_.f90->sourcefile~tensor_range_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~input_output_pair_m.f90->sourcefile~tensor_m.f90 sourcefile~mini_batch_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~mini_batch_m.f90->sourcefile~input_output_pair_m.f90 sourcefile~relu_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~relu_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~sigmoid_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~sigmoid_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~step_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~step_m.f90->sourcefile~activation_strategy_m.f90 sourcefile~swish_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~swish_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~tensor_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~tensor_range_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~inference_engine_m_.f90 sourcefile~trainable_engine_m.f90->sourcefile~mini_batch_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~tensor_range_m.f90 sourcefile~trainable_engine_m.f90->sourcefile~training_configuration_m.f90 sourcefile~training_configuration_m.f90->sourcefile~kind_parameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~differentiable_activation_strategy_m.f90 sourcefile~training_configuration_m.f90->sourcefile~hyperparameters_m.f90 sourcefile~training_configuration_m.f90->sourcefile~network_configuration_m.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! Copyright (c), The Regents of the University of California ! Terms of use are as specified in LICENSE.txt program write_read_infer !! This program demonstrates how to write a neural network to a JSON file, !! read the same network from the written file, query the network object for !! some of its properties, print those properties, and use the network to !! perform inference.  The network performs an identity mapping from any !! non-negative inputs to the corresponding outputs using a RELU activation !! function. use inference_engine_m , only : inference_engine_t , relu_t , tensor_t use julienne_m , only : string_t , command_line_t , file_t use kind_parameters_m , only : rkind implicit none type ( string_t ) file_name type ( command_line_t ) command_line file_name = string_t ( command_line % flag_value ( \"--output-file\" )) if ( len ( file_name % string ()) == 0 ) then error stop new_line ( 'a' ) // new_line ( 'a' ) // & 'Usage: fpm run --example write-read-infer --profile release --flag \"-fopenmp\" -- --output-file \"<file-name>\"' end if call write_read_query_infer ( file_name ) contains function identity_network () result ( inference_engine ) type ( inference_engine_t ) inference_engine integer , parameter :: nodes_per_layer ( * ) = [ 2 , 2 , 2 ] integer , parameter :: max_n = maxval ( nodes_per_layer ), layers = size ( nodes_per_layer ) #ifdef _CRAYFTN real ( rkind ), allocatable :: weights (:,:,:) weights = reshape ([ real ( rkind ) :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]) inference_engine = inference_engine_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = weights , & biases = reshape ([ real ( rkind ) :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) #else inference_engine = inference_engine_t ( & metadata = [ string_t ( \"Identity\" ), string_t ( \"Damian Rouson\" ), string_t ( \"2023-09-18\" ), string_t ( \"relu\" ), string_t ( \"false\" )], & weights = reshape ([ real ( rkind ) :: [ 1 , 0 , 0 , 1 ], [ 1 , 0 , 0 , 1 ]], [ max_n , max_n , layers - 1 ]), & biases = reshape ([ real ( rkind ) :: [ 0 , 0 ], [ 0 , 0 ]], [ max_n , layers - 1 ]), & nodes = nodes_per_layer & ) #endif end function subroutine write_read_query_infer ( output_file_name ) type ( string_t ), intent ( in ) :: output_file_name type ( string_t ) activation_name integer i , j integer , parameter :: num_neurons = 3 , num_hidden_layers = 2 type ( inference_engine_t ) network , inference_engine type ( file_t ) json_output_file , json_input_file type ( tensor_t ) inputs , outputs print * , \"Constructing an inference_engine_t neural-network object from scratch.\" network = identity_network () print * , \"Converting an inference_engine_t object to a file_t object.\" json_output_file = network % to_json () print * , \"Writing an inference_engine_t object to the file '\" // output_file_name % string () // \"' in JSON format.\" call json_output_file % write_lines ( output_file_name ) print * , \"Reading an inference_engine_t object from the same JSON file '\" // output_file_name % string () // \"'.\" json_input_file = file_t ( output_file_name ) print * , \"Constructing a new inference_engine_t object from the parameters read.\" inference_engine = inference_engine_t ( json_input_file ) print * , \"Querying the new inference_engine_t object for several properties:\" print * , \"Number of outputs:\" , inference_engine % num_outputs () print * , \"Number of inputs:\" , inference_engine % num_inputs () print * , \"Nodes per layer:\" , inference_engine % nodes_per_layer () activation_name = inference_engine % activation_function_name () print * , \"Activation function: \" , activation_name % string () print * , \"Performing inference:\" inputs = tensor_t ([ 2. , 3. ]) print * , \"Inputs: \" , inputs % values () outputs = inference_engine % infer ( inputs ) print * , \"Actual outputs: \" , outputs % values () print * , \"Correct outputs:  \" , inputs % values () end subroutine write_read_query_infer end program","tags":"","loc":"sourcefile/write-read-infer.f90.html"}]}